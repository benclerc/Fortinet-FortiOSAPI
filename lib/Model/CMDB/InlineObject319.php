<?php
/**
 * InlineObject319
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * InlineObject319 Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class InlineObject319 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'inline_object_319';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'group_id' => 'int',
        'group_name' => 'string',
        'mode' => 'string',
        'sync_packet_balance' => 'string',
        'password' => 'string',
        'key' => 'string',
        'hbdev' => 'string',
        'session_sync_dev' => 'string',
        'route_ttl' => 'int',
        'route_wait' => 'int',
        'route_hold' => 'int',
        'multicast_ttl' => 'int',
        'load_balance_all' => 'string',
        'sync_config' => 'string',
        'encryption' => 'string',
        'authentication' => 'string',
        'hb_interval' => 'int',
        'hb_lost_threshold' => 'int',
        'hello_holddown' => 'int',
        'gratuitous_arps' => 'string',
        'arps' => 'int',
        'arps_interval' => 'int',
        'session_pickup' => 'string',
        'session_pickup_connectionless' => 'string',
        'session_pickup_expectation' => 'string',
        'session_pickup_nat' => 'string',
        'session_pickup_delay' => 'string',
        'link_failed_signal' => 'string',
        'uninterruptible_upgrade' => 'string',
        'standalone_mgmt_vdom' => 'string',
        'ha_mgmt_status' => 'string',
        'ha_mgmt_interfaces' => '\Fortigate\FortiOS\Model\CMDB\SystemHaHaMgmtInterfaces[]',
        'ha_eth_type' => 'string',
        'hc_eth_type' => 'string',
        'l2ep_eth_type' => 'string',
        'ha_uptime_diff_margin' => 'int',
        'standalone_config_sync' => 'string',
        'logical_sn' => 'string',
        'vcluster_id' => 'int',
        'override' => 'string',
        'priority' => 'int',
        'override_wait_time' => 'int',
        'schedule' => 'string',
        'weight' => 'string',
        'cpu_threshold' => 'string',
        'memory_threshold' => 'string',
        'http_proxy_threshold' => 'string',
        'ftp_proxy_threshold' => 'string',
        'imap_proxy_threshold' => 'string',
        'nntp_proxy_threshold' => 'string',
        'pop3_proxy_threshold' => 'string',
        'smtp_proxy_threshold' => 'string',
        'monitor' => 'string',
        'pingserver_monitor_interface' => 'string',
        'pingserver_failover_threshold' => 'int',
        'pingserver_secondary_force_reset' => 'string',
        'pingserver_flip_timeout' => 'int',
        'vdom' => 'string',
        'vcluster2' => 'string',
        'secondary_vcluster' => '\Fortigate\FortiOS\Model\CMDB\SystemHaSecondaryVcluster[]',
        'ha_direct' => 'string',
        'ssd_failover' => 'string',
        'memory_compatible_mode' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'group_id' => null,
        'group_name' => null,
        'mode' => null,
        'sync_packet_balance' => null,
        'password' => 'password',
        'key' => 'password',
        'hbdev' => null,
        'session_sync_dev' => null,
        'route_ttl' => null,
        'route_wait' => null,
        'route_hold' => null,
        'multicast_ttl' => null,
        'load_balance_all' => null,
        'sync_config' => null,
        'encryption' => null,
        'authentication' => null,
        'hb_interval' => null,
        'hb_lost_threshold' => null,
        'hello_holddown' => null,
        'gratuitous_arps' => null,
        'arps' => null,
        'arps_interval' => null,
        'session_pickup' => null,
        'session_pickup_connectionless' => null,
        'session_pickup_expectation' => null,
        'session_pickup_nat' => null,
        'session_pickup_delay' => null,
        'link_failed_signal' => null,
        'uninterruptible_upgrade' => null,
        'standalone_mgmt_vdom' => null,
        'ha_mgmt_status' => null,
        'ha_mgmt_interfaces' => null,
        'ha_eth_type' => null,
        'hc_eth_type' => null,
        'l2ep_eth_type' => null,
        'ha_uptime_diff_margin' => null,
        'standalone_config_sync' => null,
        'logical_sn' => null,
        'vcluster_id' => null,
        'override' => null,
        'priority' => null,
        'override_wait_time' => null,
        'schedule' => null,
        'weight' => null,
        'cpu_threshold' => null,
        'memory_threshold' => null,
        'http_proxy_threshold' => null,
        'ftp_proxy_threshold' => null,
        'imap_proxy_threshold' => null,
        'nntp_proxy_threshold' => null,
        'pop3_proxy_threshold' => null,
        'smtp_proxy_threshold' => null,
        'monitor' => null,
        'pingserver_monitor_interface' => null,
        'pingserver_failover_threshold' => null,
        'pingserver_secondary_force_reset' => null,
        'pingserver_flip_timeout' => null,
        'vdom' => null,
        'vcluster2' => null,
        'secondary_vcluster' => null,
        'ha_direct' => null,
        'ssd_failover' => null,
        'memory_compatible_mode' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'group_id' => 'group-id',
        'group_name' => 'group-name',
        'mode' => 'mode',
        'sync_packet_balance' => 'sync-packet-balance',
        'password' => 'password',
        'key' => 'key',
        'hbdev' => 'hbdev',
        'session_sync_dev' => 'session-sync-dev',
        'route_ttl' => 'route-ttl',
        'route_wait' => 'route-wait',
        'route_hold' => 'route-hold',
        'multicast_ttl' => 'multicast-ttl',
        'load_balance_all' => 'load-balance-all',
        'sync_config' => 'sync-config',
        'encryption' => 'encryption',
        'authentication' => 'authentication',
        'hb_interval' => 'hb-interval',
        'hb_lost_threshold' => 'hb-lost-threshold',
        'hello_holddown' => 'hello-holddown',
        'gratuitous_arps' => 'gratuitous-arps',
        'arps' => 'arps',
        'arps_interval' => 'arps-interval',
        'session_pickup' => 'session-pickup',
        'session_pickup_connectionless' => 'session-pickup-connectionless',
        'session_pickup_expectation' => 'session-pickup-expectation',
        'session_pickup_nat' => 'session-pickup-nat',
        'session_pickup_delay' => 'session-pickup-delay',
        'link_failed_signal' => 'link-failed-signal',
        'uninterruptible_upgrade' => 'uninterruptible-upgrade',
        'standalone_mgmt_vdom' => 'standalone-mgmt-vdom',
        'ha_mgmt_status' => 'ha-mgmt-status',
        'ha_mgmt_interfaces' => 'ha-mgmt-interfaces',
        'ha_eth_type' => 'ha-eth-type',
        'hc_eth_type' => 'hc-eth-type',
        'l2ep_eth_type' => 'l2ep-eth-type',
        'ha_uptime_diff_margin' => 'ha-uptime-diff-margin',
        'standalone_config_sync' => 'standalone-config-sync',
        'logical_sn' => 'logical-sn',
        'vcluster_id' => 'vcluster-id',
        'override' => 'override',
        'priority' => 'priority',
        'override_wait_time' => 'override-wait-time',
        'schedule' => 'schedule',
        'weight' => 'weight',
        'cpu_threshold' => 'cpu-threshold',
        'memory_threshold' => 'memory-threshold',
        'http_proxy_threshold' => 'http-proxy-threshold',
        'ftp_proxy_threshold' => 'ftp-proxy-threshold',
        'imap_proxy_threshold' => 'imap-proxy-threshold',
        'nntp_proxy_threshold' => 'nntp-proxy-threshold',
        'pop3_proxy_threshold' => 'pop3-proxy-threshold',
        'smtp_proxy_threshold' => 'smtp-proxy-threshold',
        'monitor' => 'monitor',
        'pingserver_monitor_interface' => 'pingserver-monitor-interface',
        'pingserver_failover_threshold' => 'pingserver-failover-threshold',
        'pingserver_secondary_force_reset' => 'pingserver-secondary-force-reset',
        'pingserver_flip_timeout' => 'pingserver-flip-timeout',
        'vdom' => 'vdom',
        'vcluster2' => 'vcluster2',
        'secondary_vcluster' => 'secondary-vcluster',
        'ha_direct' => 'ha-direct',
        'ssd_failover' => 'ssd-failover',
        'memory_compatible_mode' => 'memory-compatible-mode'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'group_id' => 'setGroupId',
        'group_name' => 'setGroupName',
        'mode' => 'setMode',
        'sync_packet_balance' => 'setSyncPacketBalance',
        'password' => 'setPassword',
        'key' => 'setKey',
        'hbdev' => 'setHbdev',
        'session_sync_dev' => 'setSessionSyncDev',
        'route_ttl' => 'setRouteTtl',
        'route_wait' => 'setRouteWait',
        'route_hold' => 'setRouteHold',
        'multicast_ttl' => 'setMulticastTtl',
        'load_balance_all' => 'setLoadBalanceAll',
        'sync_config' => 'setSyncConfig',
        'encryption' => 'setEncryption',
        'authentication' => 'setAuthentication',
        'hb_interval' => 'setHbInterval',
        'hb_lost_threshold' => 'setHbLostThreshold',
        'hello_holddown' => 'setHelloHolddown',
        'gratuitous_arps' => 'setGratuitousArps',
        'arps' => 'setArps',
        'arps_interval' => 'setArpsInterval',
        'session_pickup' => 'setSessionPickup',
        'session_pickup_connectionless' => 'setSessionPickupConnectionless',
        'session_pickup_expectation' => 'setSessionPickupExpectation',
        'session_pickup_nat' => 'setSessionPickupNat',
        'session_pickup_delay' => 'setSessionPickupDelay',
        'link_failed_signal' => 'setLinkFailedSignal',
        'uninterruptible_upgrade' => 'setUninterruptibleUpgrade',
        'standalone_mgmt_vdom' => 'setStandaloneMgmtVdom',
        'ha_mgmt_status' => 'setHaMgmtStatus',
        'ha_mgmt_interfaces' => 'setHaMgmtInterfaces',
        'ha_eth_type' => 'setHaEthType',
        'hc_eth_type' => 'setHcEthType',
        'l2ep_eth_type' => 'setL2epEthType',
        'ha_uptime_diff_margin' => 'setHaUptimeDiffMargin',
        'standalone_config_sync' => 'setStandaloneConfigSync',
        'logical_sn' => 'setLogicalSn',
        'vcluster_id' => 'setVclusterId',
        'override' => 'setOverride',
        'priority' => 'setPriority',
        'override_wait_time' => 'setOverrideWaitTime',
        'schedule' => 'setSchedule',
        'weight' => 'setWeight',
        'cpu_threshold' => 'setCpuThreshold',
        'memory_threshold' => 'setMemoryThreshold',
        'http_proxy_threshold' => 'setHttpProxyThreshold',
        'ftp_proxy_threshold' => 'setFtpProxyThreshold',
        'imap_proxy_threshold' => 'setImapProxyThreshold',
        'nntp_proxy_threshold' => 'setNntpProxyThreshold',
        'pop3_proxy_threshold' => 'setPop3ProxyThreshold',
        'smtp_proxy_threshold' => 'setSmtpProxyThreshold',
        'monitor' => 'setMonitor',
        'pingserver_monitor_interface' => 'setPingserverMonitorInterface',
        'pingserver_failover_threshold' => 'setPingserverFailoverThreshold',
        'pingserver_secondary_force_reset' => 'setPingserverSecondaryForceReset',
        'pingserver_flip_timeout' => 'setPingserverFlipTimeout',
        'vdom' => 'setVdom',
        'vcluster2' => 'setVcluster2',
        'secondary_vcluster' => 'setSecondaryVcluster',
        'ha_direct' => 'setHaDirect',
        'ssd_failover' => 'setSsdFailover',
        'memory_compatible_mode' => 'setMemoryCompatibleMode'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'group_id' => 'getGroupId',
        'group_name' => 'getGroupName',
        'mode' => 'getMode',
        'sync_packet_balance' => 'getSyncPacketBalance',
        'password' => 'getPassword',
        'key' => 'getKey',
        'hbdev' => 'getHbdev',
        'session_sync_dev' => 'getSessionSyncDev',
        'route_ttl' => 'getRouteTtl',
        'route_wait' => 'getRouteWait',
        'route_hold' => 'getRouteHold',
        'multicast_ttl' => 'getMulticastTtl',
        'load_balance_all' => 'getLoadBalanceAll',
        'sync_config' => 'getSyncConfig',
        'encryption' => 'getEncryption',
        'authentication' => 'getAuthentication',
        'hb_interval' => 'getHbInterval',
        'hb_lost_threshold' => 'getHbLostThreshold',
        'hello_holddown' => 'getHelloHolddown',
        'gratuitous_arps' => 'getGratuitousArps',
        'arps' => 'getArps',
        'arps_interval' => 'getArpsInterval',
        'session_pickup' => 'getSessionPickup',
        'session_pickup_connectionless' => 'getSessionPickupConnectionless',
        'session_pickup_expectation' => 'getSessionPickupExpectation',
        'session_pickup_nat' => 'getSessionPickupNat',
        'session_pickup_delay' => 'getSessionPickupDelay',
        'link_failed_signal' => 'getLinkFailedSignal',
        'uninterruptible_upgrade' => 'getUninterruptibleUpgrade',
        'standalone_mgmt_vdom' => 'getStandaloneMgmtVdom',
        'ha_mgmt_status' => 'getHaMgmtStatus',
        'ha_mgmt_interfaces' => 'getHaMgmtInterfaces',
        'ha_eth_type' => 'getHaEthType',
        'hc_eth_type' => 'getHcEthType',
        'l2ep_eth_type' => 'getL2epEthType',
        'ha_uptime_diff_margin' => 'getHaUptimeDiffMargin',
        'standalone_config_sync' => 'getStandaloneConfigSync',
        'logical_sn' => 'getLogicalSn',
        'vcluster_id' => 'getVclusterId',
        'override' => 'getOverride',
        'priority' => 'getPriority',
        'override_wait_time' => 'getOverrideWaitTime',
        'schedule' => 'getSchedule',
        'weight' => 'getWeight',
        'cpu_threshold' => 'getCpuThreshold',
        'memory_threshold' => 'getMemoryThreshold',
        'http_proxy_threshold' => 'getHttpProxyThreshold',
        'ftp_proxy_threshold' => 'getFtpProxyThreshold',
        'imap_proxy_threshold' => 'getImapProxyThreshold',
        'nntp_proxy_threshold' => 'getNntpProxyThreshold',
        'pop3_proxy_threshold' => 'getPop3ProxyThreshold',
        'smtp_proxy_threshold' => 'getSmtpProxyThreshold',
        'monitor' => 'getMonitor',
        'pingserver_monitor_interface' => 'getPingserverMonitorInterface',
        'pingserver_failover_threshold' => 'getPingserverFailoverThreshold',
        'pingserver_secondary_force_reset' => 'getPingserverSecondaryForceReset',
        'pingserver_flip_timeout' => 'getPingserverFlipTimeout',
        'vdom' => 'getVdom',
        'vcluster2' => 'getVcluster2',
        'secondary_vcluster' => 'getSecondaryVcluster',
        'ha_direct' => 'getHaDirect',
        'ssd_failover' => 'getSsdFailover',
        'memory_compatible_mode' => 'getMemoryCompatibleMode'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const MODE_STANDALONE = 'standalone';
    const MODE_A_A = 'a-a';
    const MODE_A_P = 'a-p';
    const SYNC_PACKET_BALANCE_ENABLE = 'enable';
    const SYNC_PACKET_BALANCE_DISABLE = 'disable';
    const LOAD_BALANCE_ALL_ENABLE = 'enable';
    const LOAD_BALANCE_ALL_DISABLE = 'disable';
    const SYNC_CONFIG_ENABLE = 'enable';
    const SYNC_CONFIG_DISABLE = 'disable';
    const ENCRYPTION_ENABLE = 'enable';
    const ENCRYPTION_DISABLE = 'disable';
    const AUTHENTICATION_ENABLE = 'enable';
    const AUTHENTICATION_DISABLE = 'disable';
    const GRATUITOUS_ARPS_ENABLE = 'enable';
    const GRATUITOUS_ARPS_DISABLE = 'disable';
    const SESSION_PICKUP_ENABLE = 'enable';
    const SESSION_PICKUP_DISABLE = 'disable';
    const SESSION_PICKUP_CONNECTIONLESS_ENABLE = 'enable';
    const SESSION_PICKUP_CONNECTIONLESS_DISABLE = 'disable';
    const SESSION_PICKUP_EXPECTATION_ENABLE = 'enable';
    const SESSION_PICKUP_EXPECTATION_DISABLE = 'disable';
    const SESSION_PICKUP_NAT_ENABLE = 'enable';
    const SESSION_PICKUP_NAT_DISABLE = 'disable';
    const SESSION_PICKUP_DELAY_ENABLE = 'enable';
    const SESSION_PICKUP_DELAY_DISABLE = 'disable';
    const LINK_FAILED_SIGNAL_ENABLE = 'enable';
    const LINK_FAILED_SIGNAL_DISABLE = 'disable';
    const UNINTERRUPTIBLE_UPGRADE_ENABLE = 'enable';
    const UNINTERRUPTIBLE_UPGRADE_DISABLE = 'disable';
    const STANDALONE_MGMT_VDOM_ENABLE = 'enable';
    const STANDALONE_MGMT_VDOM_DISABLE = 'disable';
    const HA_MGMT_STATUS_ENABLE = 'enable';
    const HA_MGMT_STATUS_DISABLE = 'disable';
    const STANDALONE_CONFIG_SYNC_ENABLE = 'enable';
    const STANDALONE_CONFIG_SYNC_DISABLE = 'disable';
    const LOGICAL_SN_ENABLE = 'enable';
    const LOGICAL_SN_DISABLE = 'disable';
    const OVERRIDE_ENABLE = 'enable';
    const OVERRIDE_DISABLE = 'disable';
    const SCHEDULE_NONE = 'none';
    const SCHEDULE_HUB = 'hub';
    const SCHEDULE_LEASTCONNECTION = 'leastconnection';
    const SCHEDULE_ROUND_ROBIN = 'round-robin';
    const SCHEDULE_WEIGHT_ROUND_ROBIN = 'weight-round-robin';
    const SCHEDULE_RANDOM = 'random';
    const SCHEDULE_IP = 'ip';
    const SCHEDULE_IPPORT = 'ipport';
    const PINGSERVER_SECONDARY_FORCE_RESET_ENABLE = 'enable';
    const PINGSERVER_SECONDARY_FORCE_RESET_DISABLE = 'disable';
    const VCLUSTER2_ENABLE = 'enable';
    const VCLUSTER2_DISABLE = 'disable';
    const HA_DIRECT_ENABLE = 'enable';
    const HA_DIRECT_DISABLE = 'disable';
    const SSD_FAILOVER_ENABLE = 'enable';
    const SSD_FAILOVER_DISABLE = 'disable';
    const MEMORY_COMPATIBLE_MODE_ENABLE = 'enable';
    const MEMORY_COMPATIBLE_MODE_DISABLE = 'disable';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getModeAllowableValues()
    {
        return [
            self::MODE_STANDALONE,
            self::MODE_A_A,
            self::MODE_A_P,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSyncPacketBalanceAllowableValues()
    {
        return [
            self::SYNC_PACKET_BALANCE_ENABLE,
            self::SYNC_PACKET_BALANCE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLoadBalanceAllAllowableValues()
    {
        return [
            self::LOAD_BALANCE_ALL_ENABLE,
            self::LOAD_BALANCE_ALL_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSyncConfigAllowableValues()
    {
        return [
            self::SYNC_CONFIG_ENABLE,
            self::SYNC_CONFIG_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEncryptionAllowableValues()
    {
        return [
            self::ENCRYPTION_ENABLE,
            self::ENCRYPTION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthenticationAllowableValues()
    {
        return [
            self::AUTHENTICATION_ENABLE,
            self::AUTHENTICATION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGratuitousArpsAllowableValues()
    {
        return [
            self::GRATUITOUS_ARPS_ENABLE,
            self::GRATUITOUS_ARPS_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSessionPickupAllowableValues()
    {
        return [
            self::SESSION_PICKUP_ENABLE,
            self::SESSION_PICKUP_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSessionPickupConnectionlessAllowableValues()
    {
        return [
            self::SESSION_PICKUP_CONNECTIONLESS_ENABLE,
            self::SESSION_PICKUP_CONNECTIONLESS_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSessionPickupExpectationAllowableValues()
    {
        return [
            self::SESSION_PICKUP_EXPECTATION_ENABLE,
            self::SESSION_PICKUP_EXPECTATION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSessionPickupNatAllowableValues()
    {
        return [
            self::SESSION_PICKUP_NAT_ENABLE,
            self::SESSION_PICKUP_NAT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSessionPickupDelayAllowableValues()
    {
        return [
            self::SESSION_PICKUP_DELAY_ENABLE,
            self::SESSION_PICKUP_DELAY_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLinkFailedSignalAllowableValues()
    {
        return [
            self::LINK_FAILED_SIGNAL_ENABLE,
            self::LINK_FAILED_SIGNAL_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getUninterruptibleUpgradeAllowableValues()
    {
        return [
            self::UNINTERRUPTIBLE_UPGRADE_ENABLE,
            self::UNINTERRUPTIBLE_UPGRADE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStandaloneMgmtVdomAllowableValues()
    {
        return [
            self::STANDALONE_MGMT_VDOM_ENABLE,
            self::STANDALONE_MGMT_VDOM_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHaMgmtStatusAllowableValues()
    {
        return [
            self::HA_MGMT_STATUS_ENABLE,
            self::HA_MGMT_STATUS_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStandaloneConfigSyncAllowableValues()
    {
        return [
            self::STANDALONE_CONFIG_SYNC_ENABLE,
            self::STANDALONE_CONFIG_SYNC_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLogicalSnAllowableValues()
    {
        return [
            self::LOGICAL_SN_ENABLE,
            self::LOGICAL_SN_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOverrideAllowableValues()
    {
        return [
            self::OVERRIDE_ENABLE,
            self::OVERRIDE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScheduleAllowableValues()
    {
        return [
            self::SCHEDULE_NONE,
            self::SCHEDULE_HUB,
            self::SCHEDULE_LEASTCONNECTION,
            self::SCHEDULE_ROUND_ROBIN,
            self::SCHEDULE_WEIGHT_ROUND_ROBIN,
            self::SCHEDULE_RANDOM,
            self::SCHEDULE_IP,
            self::SCHEDULE_IPPORT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPingserverSecondaryForceResetAllowableValues()
    {
        return [
            self::PINGSERVER_SECONDARY_FORCE_RESET_ENABLE,
            self::PINGSERVER_SECONDARY_FORCE_RESET_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVcluster2AllowableValues()
    {
        return [
            self::VCLUSTER2_ENABLE,
            self::VCLUSTER2_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHaDirectAllowableValues()
    {
        return [
            self::HA_DIRECT_ENABLE,
            self::HA_DIRECT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSsdFailoverAllowableValues()
    {
        return [
            self::SSD_FAILOVER_ENABLE,
            self::SSD_FAILOVER_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMemoryCompatibleModeAllowableValues()
    {
        return [
            self::MEMORY_COMPATIBLE_MODE_ENABLE,
            self::MEMORY_COMPATIBLE_MODE_DISABLE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['group_id'] = $data['group_id'] ?? null;
        $this->container['group_name'] = $data['group_name'] ?? null;
        $this->container['mode'] = $data['mode'] ?? null;
        $this->container['sync_packet_balance'] = $data['sync_packet_balance'] ?? null;
        $this->container['password'] = $data['password'] ?? null;
        $this->container['key'] = $data['key'] ?? null;
        $this->container['hbdev'] = $data['hbdev'] ?? null;
        $this->container['session_sync_dev'] = $data['session_sync_dev'] ?? null;
        $this->container['route_ttl'] = $data['route_ttl'] ?? null;
        $this->container['route_wait'] = $data['route_wait'] ?? null;
        $this->container['route_hold'] = $data['route_hold'] ?? null;
        $this->container['multicast_ttl'] = $data['multicast_ttl'] ?? null;
        $this->container['load_balance_all'] = $data['load_balance_all'] ?? null;
        $this->container['sync_config'] = $data['sync_config'] ?? null;
        $this->container['encryption'] = $data['encryption'] ?? null;
        $this->container['authentication'] = $data['authentication'] ?? null;
        $this->container['hb_interval'] = $data['hb_interval'] ?? null;
        $this->container['hb_lost_threshold'] = $data['hb_lost_threshold'] ?? null;
        $this->container['hello_holddown'] = $data['hello_holddown'] ?? null;
        $this->container['gratuitous_arps'] = $data['gratuitous_arps'] ?? null;
        $this->container['arps'] = $data['arps'] ?? null;
        $this->container['arps_interval'] = $data['arps_interval'] ?? null;
        $this->container['session_pickup'] = $data['session_pickup'] ?? null;
        $this->container['session_pickup_connectionless'] = $data['session_pickup_connectionless'] ?? null;
        $this->container['session_pickup_expectation'] = $data['session_pickup_expectation'] ?? null;
        $this->container['session_pickup_nat'] = $data['session_pickup_nat'] ?? null;
        $this->container['session_pickup_delay'] = $data['session_pickup_delay'] ?? null;
        $this->container['link_failed_signal'] = $data['link_failed_signal'] ?? null;
        $this->container['uninterruptible_upgrade'] = $data['uninterruptible_upgrade'] ?? null;
        $this->container['standalone_mgmt_vdom'] = $data['standalone_mgmt_vdom'] ?? null;
        $this->container['ha_mgmt_status'] = $data['ha_mgmt_status'] ?? null;
        $this->container['ha_mgmt_interfaces'] = $data['ha_mgmt_interfaces'] ?? null;
        $this->container['ha_eth_type'] = $data['ha_eth_type'] ?? null;
        $this->container['hc_eth_type'] = $data['hc_eth_type'] ?? null;
        $this->container['l2ep_eth_type'] = $data['l2ep_eth_type'] ?? null;
        $this->container['ha_uptime_diff_margin'] = $data['ha_uptime_diff_margin'] ?? null;
        $this->container['standalone_config_sync'] = $data['standalone_config_sync'] ?? null;
        $this->container['logical_sn'] = $data['logical_sn'] ?? null;
        $this->container['vcluster_id'] = $data['vcluster_id'] ?? null;
        $this->container['override'] = $data['override'] ?? null;
        $this->container['priority'] = $data['priority'] ?? null;
        $this->container['override_wait_time'] = $data['override_wait_time'] ?? null;
        $this->container['schedule'] = $data['schedule'] ?? null;
        $this->container['weight'] = $data['weight'] ?? null;
        $this->container['cpu_threshold'] = $data['cpu_threshold'] ?? null;
        $this->container['memory_threshold'] = $data['memory_threshold'] ?? null;
        $this->container['http_proxy_threshold'] = $data['http_proxy_threshold'] ?? null;
        $this->container['ftp_proxy_threshold'] = $data['ftp_proxy_threshold'] ?? null;
        $this->container['imap_proxy_threshold'] = $data['imap_proxy_threshold'] ?? null;
        $this->container['nntp_proxy_threshold'] = $data['nntp_proxy_threshold'] ?? null;
        $this->container['pop3_proxy_threshold'] = $data['pop3_proxy_threshold'] ?? null;
        $this->container['smtp_proxy_threshold'] = $data['smtp_proxy_threshold'] ?? null;
        $this->container['monitor'] = $data['monitor'] ?? null;
        $this->container['pingserver_monitor_interface'] = $data['pingserver_monitor_interface'] ?? null;
        $this->container['pingserver_failover_threshold'] = $data['pingserver_failover_threshold'] ?? null;
        $this->container['pingserver_secondary_force_reset'] = $data['pingserver_secondary_force_reset'] ?? null;
        $this->container['pingserver_flip_timeout'] = $data['pingserver_flip_timeout'] ?? null;
        $this->container['vdom'] = $data['vdom'] ?? null;
        $this->container['vcluster2'] = $data['vcluster2'] ?? null;
        $this->container['secondary_vcluster'] = $data['secondary_vcluster'] ?? null;
        $this->container['ha_direct'] = $data['ha_direct'] ?? null;
        $this->container['ssd_failover'] = $data['ssd_failover'] ?? null;
        $this->container['memory_compatible_mode'] = $data['memory_compatible_mode'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['group_id']) && ($this->container['group_id'] > 255)) {
            $invalidProperties[] = "invalid value for 'group_id', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['group_id']) && ($this->container['group_id'] < 0)) {
            $invalidProperties[] = "invalid value for 'group_id', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['group_name']) && (mb_strlen($this->container['group_name']) > 32)) {
            $invalidProperties[] = "invalid value for 'group_name', the character length must be smaller than or equal to 32.";
        }

        $allowedValues = $this->getModeAllowableValues();
        if (!is_null($this->container['mode']) && !in_array($this->container['mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'mode', must be one of '%s'",
                $this->container['mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSyncPacketBalanceAllowableValues();
        if (!is_null($this->container['sync_packet_balance']) && !in_array($this->container['sync_packet_balance'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sync_packet_balance', must be one of '%s'",
                $this->container['sync_packet_balance'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['route_ttl']) && ($this->container['route_ttl'] > 3600)) {
            $invalidProperties[] = "invalid value for 'route_ttl', must be smaller than or equal to 3600.";
        }

        if (!is_null($this->container['route_ttl']) && ($this->container['route_ttl'] < 5)) {
            $invalidProperties[] = "invalid value for 'route_ttl', must be bigger than or equal to 5.";
        }

        if (!is_null($this->container['route_wait']) && ($this->container['route_wait'] > 3600)) {
            $invalidProperties[] = "invalid value for 'route_wait', must be smaller than or equal to 3600.";
        }

        if (!is_null($this->container['route_wait']) && ($this->container['route_wait'] < 0)) {
            $invalidProperties[] = "invalid value for 'route_wait', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['route_hold']) && ($this->container['route_hold'] > 3600)) {
            $invalidProperties[] = "invalid value for 'route_hold', must be smaller than or equal to 3600.";
        }

        if (!is_null($this->container['route_hold']) && ($this->container['route_hold'] < 0)) {
            $invalidProperties[] = "invalid value for 'route_hold', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['multicast_ttl']) && ($this->container['multicast_ttl'] > 3600)) {
            $invalidProperties[] = "invalid value for 'multicast_ttl', must be smaller than or equal to 3600.";
        }

        if (!is_null($this->container['multicast_ttl']) && ($this->container['multicast_ttl'] < 5)) {
            $invalidProperties[] = "invalid value for 'multicast_ttl', must be bigger than or equal to 5.";
        }

        $allowedValues = $this->getLoadBalanceAllAllowableValues();
        if (!is_null($this->container['load_balance_all']) && !in_array($this->container['load_balance_all'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'load_balance_all', must be one of '%s'",
                $this->container['load_balance_all'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSyncConfigAllowableValues();
        if (!is_null($this->container['sync_config']) && !in_array($this->container['sync_config'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sync_config', must be one of '%s'",
                $this->container['sync_config'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEncryptionAllowableValues();
        if (!is_null($this->container['encryption']) && !in_array($this->container['encryption'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'encryption', must be one of '%s'",
                $this->container['encryption'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthenticationAllowableValues();
        if (!is_null($this->container['authentication']) && !in_array($this->container['authentication'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'authentication', must be one of '%s'",
                $this->container['authentication'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['hb_interval']) && ($this->container['hb_interval'] > 20)) {
            $invalidProperties[] = "invalid value for 'hb_interval', must be smaller than or equal to 20.";
        }

        if (!is_null($this->container['hb_interval']) && ($this->container['hb_interval'] < 1)) {
            $invalidProperties[] = "invalid value for 'hb_interval', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['hb_lost_threshold']) && ($this->container['hb_lost_threshold'] > 60)) {
            $invalidProperties[] = "invalid value for 'hb_lost_threshold', must be smaller than or equal to 60.";
        }

        if (!is_null($this->container['hb_lost_threshold']) && ($this->container['hb_lost_threshold'] < 1)) {
            $invalidProperties[] = "invalid value for 'hb_lost_threshold', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['hello_holddown']) && ($this->container['hello_holddown'] > 300)) {
            $invalidProperties[] = "invalid value for 'hello_holddown', must be smaller than or equal to 300.";
        }

        if (!is_null($this->container['hello_holddown']) && ($this->container['hello_holddown'] < 5)) {
            $invalidProperties[] = "invalid value for 'hello_holddown', must be bigger than or equal to 5.";
        }

        $allowedValues = $this->getGratuitousArpsAllowableValues();
        if (!is_null($this->container['gratuitous_arps']) && !in_array($this->container['gratuitous_arps'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'gratuitous_arps', must be one of '%s'",
                $this->container['gratuitous_arps'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['arps']) && ($this->container['arps'] > 60)) {
            $invalidProperties[] = "invalid value for 'arps', must be smaller than or equal to 60.";
        }

        if (!is_null($this->container['arps']) && ($this->container['arps'] < 1)) {
            $invalidProperties[] = "invalid value for 'arps', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['arps_interval']) && ($this->container['arps_interval'] > 20)) {
            $invalidProperties[] = "invalid value for 'arps_interval', must be smaller than or equal to 20.";
        }

        if (!is_null($this->container['arps_interval']) && ($this->container['arps_interval'] < 1)) {
            $invalidProperties[] = "invalid value for 'arps_interval', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getSessionPickupAllowableValues();
        if (!is_null($this->container['session_pickup']) && !in_array($this->container['session_pickup'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'session_pickup', must be one of '%s'",
                $this->container['session_pickup'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSessionPickupConnectionlessAllowableValues();
        if (!is_null($this->container['session_pickup_connectionless']) && !in_array($this->container['session_pickup_connectionless'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'session_pickup_connectionless', must be one of '%s'",
                $this->container['session_pickup_connectionless'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSessionPickupExpectationAllowableValues();
        if (!is_null($this->container['session_pickup_expectation']) && !in_array($this->container['session_pickup_expectation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'session_pickup_expectation', must be one of '%s'",
                $this->container['session_pickup_expectation'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSessionPickupNatAllowableValues();
        if (!is_null($this->container['session_pickup_nat']) && !in_array($this->container['session_pickup_nat'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'session_pickup_nat', must be one of '%s'",
                $this->container['session_pickup_nat'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSessionPickupDelayAllowableValues();
        if (!is_null($this->container['session_pickup_delay']) && !in_array($this->container['session_pickup_delay'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'session_pickup_delay', must be one of '%s'",
                $this->container['session_pickup_delay'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLinkFailedSignalAllowableValues();
        if (!is_null($this->container['link_failed_signal']) && !in_array($this->container['link_failed_signal'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'link_failed_signal', must be one of '%s'",
                $this->container['link_failed_signal'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getUninterruptibleUpgradeAllowableValues();
        if (!is_null($this->container['uninterruptible_upgrade']) && !in_array($this->container['uninterruptible_upgrade'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'uninterruptible_upgrade', must be one of '%s'",
                $this->container['uninterruptible_upgrade'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStandaloneMgmtVdomAllowableValues();
        if (!is_null($this->container['standalone_mgmt_vdom']) && !in_array($this->container['standalone_mgmt_vdom'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'standalone_mgmt_vdom', must be one of '%s'",
                $this->container['standalone_mgmt_vdom'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHaMgmtStatusAllowableValues();
        if (!is_null($this->container['ha_mgmt_status']) && !in_array($this->container['ha_mgmt_status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ha_mgmt_status', must be one of '%s'",
                $this->container['ha_mgmt_status'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['ha_mgmt_interfaces']) && (count($this->container['ha_mgmt_interfaces']) > 0)) {
            $invalidProperties[] = "invalid value for 'ha_mgmt_interfaces', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['ha_eth_type']) && (mb_strlen($this->container['ha_eth_type']) > 4)) {
            $invalidProperties[] = "invalid value for 'ha_eth_type', the character length must be smaller than or equal to 4.";
        }

        if (!is_null($this->container['hc_eth_type']) && (mb_strlen($this->container['hc_eth_type']) > 4)) {
            $invalidProperties[] = "invalid value for 'hc_eth_type', the character length must be smaller than or equal to 4.";
        }

        if (!is_null($this->container['l2ep_eth_type']) && (mb_strlen($this->container['l2ep_eth_type']) > 4)) {
            $invalidProperties[] = "invalid value for 'l2ep_eth_type', the character length must be smaller than or equal to 4.";
        }

        if (!is_null($this->container['ha_uptime_diff_margin']) && ($this->container['ha_uptime_diff_margin'] > 65535)) {
            $invalidProperties[] = "invalid value for 'ha_uptime_diff_margin', must be smaller than or equal to 65535.";
        }

        if (!is_null($this->container['ha_uptime_diff_margin']) && ($this->container['ha_uptime_diff_margin'] < 1)) {
            $invalidProperties[] = "invalid value for 'ha_uptime_diff_margin', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getStandaloneConfigSyncAllowableValues();
        if (!is_null($this->container['standalone_config_sync']) && !in_array($this->container['standalone_config_sync'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'standalone_config_sync', must be one of '%s'",
                $this->container['standalone_config_sync'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLogicalSnAllowableValues();
        if (!is_null($this->container['logical_sn']) && !in_array($this->container['logical_sn'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'logical_sn', must be one of '%s'",
                $this->container['logical_sn'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['vcluster_id']) && ($this->container['vcluster_id'] > 255)) {
            $invalidProperties[] = "invalid value for 'vcluster_id', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['vcluster_id']) && ($this->container['vcluster_id'] < 0)) {
            $invalidProperties[] = "invalid value for 'vcluster_id', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getOverrideAllowableValues();
        if (!is_null($this->container['override']) && !in_array($this->container['override'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'override', must be one of '%s'",
                $this->container['override'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['priority']) && ($this->container['priority'] > 255)) {
            $invalidProperties[] = "invalid value for 'priority', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['priority']) && ($this->container['priority'] < 0)) {
            $invalidProperties[] = "invalid value for 'priority', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['override_wait_time']) && ($this->container['override_wait_time'] > 3600)) {
            $invalidProperties[] = "invalid value for 'override_wait_time', must be smaller than or equal to 3600.";
        }

        if (!is_null($this->container['override_wait_time']) && ($this->container['override_wait_time'] < 0)) {
            $invalidProperties[] = "invalid value for 'override_wait_time', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getScheduleAllowableValues();
        if (!is_null($this->container['schedule']) && !in_array($this->container['schedule'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'schedule', must be one of '%s'",
                $this->container['schedule'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['pingserver_failover_threshold']) && ($this->container['pingserver_failover_threshold'] > 50)) {
            $invalidProperties[] = "invalid value for 'pingserver_failover_threshold', must be smaller than or equal to 50.";
        }

        if (!is_null($this->container['pingserver_failover_threshold']) && ($this->container['pingserver_failover_threshold'] < 0)) {
            $invalidProperties[] = "invalid value for 'pingserver_failover_threshold', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getPingserverSecondaryForceResetAllowableValues();
        if (!is_null($this->container['pingserver_secondary_force_reset']) && !in_array($this->container['pingserver_secondary_force_reset'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'pingserver_secondary_force_reset', must be one of '%s'",
                $this->container['pingserver_secondary_force_reset'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['pingserver_flip_timeout']) && ($this->container['pingserver_flip_timeout'] > 2147483647)) {
            $invalidProperties[] = "invalid value for 'pingserver_flip_timeout', must be smaller than or equal to 2147483647.";
        }

        if (!is_null($this->container['pingserver_flip_timeout']) && ($this->container['pingserver_flip_timeout'] < 6)) {
            $invalidProperties[] = "invalid value for 'pingserver_flip_timeout', must be bigger than or equal to 6.";
        }

        $allowedValues = $this->getVcluster2AllowableValues();
        if (!is_null($this->container['vcluster2']) && !in_array($this->container['vcluster2'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'vcluster2', must be one of '%s'",
                $this->container['vcluster2'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['secondary_vcluster']) && (count($this->container['secondary_vcluster']) > 0)) {
            $invalidProperties[] = "invalid value for 'secondary_vcluster', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getHaDirectAllowableValues();
        if (!is_null($this->container['ha_direct']) && !in_array($this->container['ha_direct'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ha_direct', must be one of '%s'",
                $this->container['ha_direct'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSsdFailoverAllowableValues();
        if (!is_null($this->container['ssd_failover']) && !in_array($this->container['ssd_failover'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ssd_failover', must be one of '%s'",
                $this->container['ssd_failover'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getMemoryCompatibleModeAllowableValues();
        if (!is_null($this->container['memory_compatible_mode']) && !in_array($this->container['memory_compatible_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'memory_compatible_mode', must be one of '%s'",
                $this->container['memory_compatible_mode'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets group_id
     *
     * @return int|null
     */
    public function getGroupId()
    {
        return $this->container['group_id'];
    }

    /**
     * Sets group_id
     *
     * @param int|null $group_id HA group ID  (0 - 255). Must be the same for all members.
     *
     * @return self
     */
    public function setGroupId($group_id)
    {

        if (!is_null($group_id) && ($group_id > 255)) {
            throw new \InvalidArgumentException('invalid value for $group_id when calling InlineObject319., must be smaller than or equal to 255.');
        }
        if (!is_null($group_id) && ($group_id < 0)) {
            throw new \InvalidArgumentException('invalid value for $group_id when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['group_id'] = $group_id;

        return $this;
    }

    /**
     * Gets group_name
     *
     * @return string|null
     */
    public function getGroupName()
    {
        return $this->container['group_name'];
    }

    /**
     * Sets group_name
     *
     * @param string|null $group_name Cluster group name. Must be the same for all members.
     *
     * @return self
     */
    public function setGroupName($group_name)
    {
        if (!is_null($group_name) && (mb_strlen($group_name) > 32)) {
            throw new \InvalidArgumentException('invalid length for $group_name when calling InlineObject319., must be smaller than or equal to 32.');
        }

        $this->container['group_name'] = $group_name;

        return $this;
    }

    /**
     * Gets mode
     *
     * @return string|null
     */
    public function getMode()
    {
        return $this->container['mode'];
    }

    /**
     * Sets mode
     *
     * @param string|null $mode HA mode. Must be the same for all members. FGSP requires standalone.    standalone:Standalone mode.    a-a:Active-active mode.    a-p:Active-passive mode.
     *
     * @return self
     */
    public function setMode($mode)
    {
        $allowedValues = $this->getModeAllowableValues();
        if (!is_null($mode) && !in_array($mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'mode', must be one of '%s'",
                    $mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mode'] = $mode;

        return $this;
    }

    /**
     * Gets sync_packet_balance
     *
     * @return string|null
     */
    public function getSyncPacketBalance()
    {
        return $this->container['sync_packet_balance'];
    }

    /**
     * Sets sync_packet_balance
     *
     * @param string|null $sync_packet_balance Enable/disable HA packet distribution to multiple CPUs.    enable:Enable HA packet distribution to multiple CPUs.    disable:Disable HA packet distribution to multiple CPUs.
     *
     * @return self
     */
    public function setSyncPacketBalance($sync_packet_balance)
    {
        $allowedValues = $this->getSyncPacketBalanceAllowableValues();
        if (!is_null($sync_packet_balance) && !in_array($sync_packet_balance, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sync_packet_balance', must be one of '%s'",
                    $sync_packet_balance,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sync_packet_balance'] = $sync_packet_balance;

        return $this;
    }

    /**
     * Gets password
     *
     * @return string|null
     */
    public function getPassword()
    {
        return $this->container['password'];
    }

    /**
     * Sets password
     *
     * @param string|null $password Cluster password. Must be the same for all members.
     *
     * @return self
     */
    public function setPassword($password)
    {
        $this->container['password'] = $password;

        return $this;
    }

    /**
     * Gets key
     *
     * @return string|null
     */
    public function getKey()
    {
        return $this->container['key'];
    }

    /**
     * Sets key
     *
     * @param string|null $key key
     *
     * @return self
     */
    public function setKey($key)
    {
        $this->container['key'] = $key;

        return $this;
    }

    /**
     * Gets hbdev
     *
     * @return string|null
     */
    public function getHbdev()
    {
        return $this->container['hbdev'];
    }

    /**
     * Sets hbdev
     *
     * @param string|null $hbdev Heartbeat interfaces. Must be the same for all members.
     *
     * @return self
     */
    public function setHbdev($hbdev)
    {
        $this->container['hbdev'] = $hbdev;

        return $this;
    }

    /**
     * Gets session_sync_dev
     *
     * @return string|null
     */
    public function getSessionSyncDev()
    {
        return $this->container['session_sync_dev'];
    }

    /**
     * Sets session_sync_dev
     *
     * @param string|null $session_sync_dev Offload session-sync process to kernel and sync sessions using connected interface(s) directly.
     *
     * @return self
     */
    public function setSessionSyncDev($session_sync_dev)
    {
        $this->container['session_sync_dev'] = $session_sync_dev;

        return $this;
    }

    /**
     * Gets route_ttl
     *
     * @return int|null
     */
    public function getRouteTtl()
    {
        return $this->container['route_ttl'];
    }

    /**
     * Sets route_ttl
     *
     * @param int|null $route_ttl TTL for primary unit routes (5 - 3600 sec). Increase to maintain active routes during failover.
     *
     * @return self
     */
    public function setRouteTtl($route_ttl)
    {

        if (!is_null($route_ttl) && ($route_ttl > 3600)) {
            throw new \InvalidArgumentException('invalid value for $route_ttl when calling InlineObject319., must be smaller than or equal to 3600.');
        }
        if (!is_null($route_ttl) && ($route_ttl < 5)) {
            throw new \InvalidArgumentException('invalid value for $route_ttl when calling InlineObject319., must be bigger than or equal to 5.');
        }

        $this->container['route_ttl'] = $route_ttl;

        return $this;
    }

    /**
     * Gets route_wait
     *
     * @return int|null
     */
    public function getRouteWait()
    {
        return $this->container['route_wait'];
    }

    /**
     * Sets route_wait
     *
     * @param int|null $route_wait Time to wait before sending new routes to the cluster (0 - 3600 sec).
     *
     * @return self
     */
    public function setRouteWait($route_wait)
    {

        if (!is_null($route_wait) && ($route_wait > 3600)) {
            throw new \InvalidArgumentException('invalid value for $route_wait when calling InlineObject319., must be smaller than or equal to 3600.');
        }
        if (!is_null($route_wait) && ($route_wait < 0)) {
            throw new \InvalidArgumentException('invalid value for $route_wait when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['route_wait'] = $route_wait;

        return $this;
    }

    /**
     * Gets route_hold
     *
     * @return int|null
     */
    public function getRouteHold()
    {
        return $this->container['route_hold'];
    }

    /**
     * Sets route_hold
     *
     * @param int|null $route_hold Time to wait between routing table updates to the cluster (0 - 3600 sec).
     *
     * @return self
     */
    public function setRouteHold($route_hold)
    {

        if (!is_null($route_hold) && ($route_hold > 3600)) {
            throw new \InvalidArgumentException('invalid value for $route_hold when calling InlineObject319., must be smaller than or equal to 3600.');
        }
        if (!is_null($route_hold) && ($route_hold < 0)) {
            throw new \InvalidArgumentException('invalid value for $route_hold when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['route_hold'] = $route_hold;

        return $this;
    }

    /**
     * Gets multicast_ttl
     *
     * @return int|null
     */
    public function getMulticastTtl()
    {
        return $this->container['multicast_ttl'];
    }

    /**
     * Sets multicast_ttl
     *
     * @param int|null $multicast_ttl HA multicast TTL on primary (5 - 3600 sec).
     *
     * @return self
     */
    public function setMulticastTtl($multicast_ttl)
    {

        if (!is_null($multicast_ttl) && ($multicast_ttl > 3600)) {
            throw new \InvalidArgumentException('invalid value for $multicast_ttl when calling InlineObject319., must be smaller than or equal to 3600.');
        }
        if (!is_null($multicast_ttl) && ($multicast_ttl < 5)) {
            throw new \InvalidArgumentException('invalid value for $multicast_ttl when calling InlineObject319., must be bigger than or equal to 5.');
        }

        $this->container['multicast_ttl'] = $multicast_ttl;

        return $this;
    }

    /**
     * Gets load_balance_all
     *
     * @return string|null
     */
    public function getLoadBalanceAll()
    {
        return $this->container['load_balance_all'];
    }

    /**
     * Sets load_balance_all
     *
     * @param string|null $load_balance_all Enable to load balance TCP sessions. Disable to load balance proxy sessions only.    enable:Enable load balance.    disable:Disable load balance.
     *
     * @return self
     */
    public function setLoadBalanceAll($load_balance_all)
    {
        $allowedValues = $this->getLoadBalanceAllAllowableValues();
        if (!is_null($load_balance_all) && !in_array($load_balance_all, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'load_balance_all', must be one of '%s'",
                    $load_balance_all,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['load_balance_all'] = $load_balance_all;

        return $this;
    }

    /**
     * Gets sync_config
     *
     * @return string|null
     */
    public function getSyncConfig()
    {
        return $this->container['sync_config'];
    }

    /**
     * Sets sync_config
     *
     * @param string|null $sync_config Enable/disable configuration synchronization.    enable:Enable configuration synchronization.    disable:Disable configuration synchronization.
     *
     * @return self
     */
    public function setSyncConfig($sync_config)
    {
        $allowedValues = $this->getSyncConfigAllowableValues();
        if (!is_null($sync_config) && !in_array($sync_config, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sync_config', must be one of '%s'",
                    $sync_config,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sync_config'] = $sync_config;

        return $this;
    }

    /**
     * Gets encryption
     *
     * @return string|null
     */
    public function getEncryption()
    {
        return $this->container['encryption'];
    }

    /**
     * Sets encryption
     *
     * @param string|null $encryption Enable/disable heartbeat message encryption.    enable:Enable heartbeat message encryption.    disable:Disable heartbeat message encryption.
     *
     * @return self
     */
    public function setEncryption($encryption)
    {
        $allowedValues = $this->getEncryptionAllowableValues();
        if (!is_null($encryption) && !in_array($encryption, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'encryption', must be one of '%s'",
                    $encryption,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['encryption'] = $encryption;

        return $this;
    }

    /**
     * Gets authentication
     *
     * @return string|null
     */
    public function getAuthentication()
    {
        return $this->container['authentication'];
    }

    /**
     * Sets authentication
     *
     * @param string|null $authentication Enable/disable heartbeat message authentication.    enable:Enable heartbeat message authentication.    disable:Disable heartbeat message authentication.
     *
     * @return self
     */
    public function setAuthentication($authentication)
    {
        $allowedValues = $this->getAuthenticationAllowableValues();
        if (!is_null($authentication) && !in_array($authentication, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'authentication', must be one of '%s'",
                    $authentication,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['authentication'] = $authentication;

        return $this;
    }

    /**
     * Gets hb_interval
     *
     * @return int|null
     */
    public function getHbInterval()
    {
        return $this->container['hb_interval'];
    }

    /**
     * Sets hb_interval
     *
     * @param int|null $hb_interval Time between sending heartbeat packets (1 - 20 (100*ms)). Increase to reduce false positives.
     *
     * @return self
     */
    public function setHbInterval($hb_interval)
    {

        if (!is_null($hb_interval) && ($hb_interval > 20)) {
            throw new \InvalidArgumentException('invalid value for $hb_interval when calling InlineObject319., must be smaller than or equal to 20.');
        }
        if (!is_null($hb_interval) && ($hb_interval < 1)) {
            throw new \InvalidArgumentException('invalid value for $hb_interval when calling InlineObject319., must be bigger than or equal to 1.');
        }

        $this->container['hb_interval'] = $hb_interval;

        return $this;
    }

    /**
     * Gets hb_lost_threshold
     *
     * @return int|null
     */
    public function getHbLostThreshold()
    {
        return $this->container['hb_lost_threshold'];
    }

    /**
     * Sets hb_lost_threshold
     *
     * @param int|null $hb_lost_threshold Number of lost heartbeats to signal a failure (1 - 60). Increase to reduce false positives.
     *
     * @return self
     */
    public function setHbLostThreshold($hb_lost_threshold)
    {

        if (!is_null($hb_lost_threshold) && ($hb_lost_threshold > 60)) {
            throw new \InvalidArgumentException('invalid value for $hb_lost_threshold when calling InlineObject319., must be smaller than or equal to 60.');
        }
        if (!is_null($hb_lost_threshold) && ($hb_lost_threshold < 1)) {
            throw new \InvalidArgumentException('invalid value for $hb_lost_threshold when calling InlineObject319., must be bigger than or equal to 1.');
        }

        $this->container['hb_lost_threshold'] = $hb_lost_threshold;

        return $this;
    }

    /**
     * Gets hello_holddown
     *
     * @return int|null
     */
    public function getHelloHolddown()
    {
        return $this->container['hello_holddown'];
    }

    /**
     * Sets hello_holddown
     *
     * @param int|null $hello_holddown Time to wait before changing from hello to work state (5 - 300 sec).
     *
     * @return self
     */
    public function setHelloHolddown($hello_holddown)
    {

        if (!is_null($hello_holddown) && ($hello_holddown > 300)) {
            throw new \InvalidArgumentException('invalid value for $hello_holddown when calling InlineObject319., must be smaller than or equal to 300.');
        }
        if (!is_null($hello_holddown) && ($hello_holddown < 5)) {
            throw new \InvalidArgumentException('invalid value for $hello_holddown when calling InlineObject319., must be bigger than or equal to 5.');
        }

        $this->container['hello_holddown'] = $hello_holddown;

        return $this;
    }

    /**
     * Gets gratuitous_arps
     *
     * @return string|null
     */
    public function getGratuitousArps()
    {
        return $this->container['gratuitous_arps'];
    }

    /**
     * Sets gratuitous_arps
     *
     * @param string|null $gratuitous_arps Enable/disable gratuitous ARPs. Disable if link-failed-signal enabled.    enable:Enable gratuitous ARPs.    disable:Disable gratuitous ARPs.
     *
     * @return self
     */
    public function setGratuitousArps($gratuitous_arps)
    {
        $allowedValues = $this->getGratuitousArpsAllowableValues();
        if (!is_null($gratuitous_arps) && !in_array($gratuitous_arps, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'gratuitous_arps', must be one of '%s'",
                    $gratuitous_arps,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['gratuitous_arps'] = $gratuitous_arps;

        return $this;
    }

    /**
     * Gets arps
     *
     * @return int|null
     */
    public function getArps()
    {
        return $this->container['arps'];
    }

    /**
     * Sets arps
     *
     * @param int|null $arps Number of gratuitous ARPs (1 - 60). Lower to reduce traffic. Higher to reduce failover time.
     *
     * @return self
     */
    public function setArps($arps)
    {

        if (!is_null($arps) && ($arps > 60)) {
            throw new \InvalidArgumentException('invalid value for $arps when calling InlineObject319., must be smaller than or equal to 60.');
        }
        if (!is_null($arps) && ($arps < 1)) {
            throw new \InvalidArgumentException('invalid value for $arps when calling InlineObject319., must be bigger than or equal to 1.');
        }

        $this->container['arps'] = $arps;

        return $this;
    }

    /**
     * Gets arps_interval
     *
     * @return int|null
     */
    public function getArpsInterval()
    {
        return $this->container['arps_interval'];
    }

    /**
     * Sets arps_interval
     *
     * @param int|null $arps_interval Time between gratuitous ARPs  (1 - 20 sec). Lower to reduce failover time. Higher to reduce traffic.
     *
     * @return self
     */
    public function setArpsInterval($arps_interval)
    {

        if (!is_null($arps_interval) && ($arps_interval > 20)) {
            throw new \InvalidArgumentException('invalid value for $arps_interval when calling InlineObject319., must be smaller than or equal to 20.');
        }
        if (!is_null($arps_interval) && ($arps_interval < 1)) {
            throw new \InvalidArgumentException('invalid value for $arps_interval when calling InlineObject319., must be bigger than or equal to 1.');
        }

        $this->container['arps_interval'] = $arps_interval;

        return $this;
    }

    /**
     * Gets session_pickup
     *
     * @return string|null
     */
    public function getSessionPickup()
    {
        return $this->container['session_pickup'];
    }

    /**
     * Sets session_pickup
     *
     * @param string|null $session_pickup Enable/disable session pickup. Enabling it can reduce session down time when fail over happens.    enable:Enable session pickup.    disable:Disable session pickup.
     *
     * @return self
     */
    public function setSessionPickup($session_pickup)
    {
        $allowedValues = $this->getSessionPickupAllowableValues();
        if (!is_null($session_pickup) && !in_array($session_pickup, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'session_pickup', must be one of '%s'",
                    $session_pickup,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['session_pickup'] = $session_pickup;

        return $this;
    }

    /**
     * Gets session_pickup_connectionless
     *
     * @return string|null
     */
    public function getSessionPickupConnectionless()
    {
        return $this->container['session_pickup_connectionless'];
    }

    /**
     * Sets session_pickup_connectionless
     *
     * @param string|null $session_pickup_connectionless Enable/disable UDP and ICMP session sync.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSessionPickupConnectionless($session_pickup_connectionless)
    {
        $allowedValues = $this->getSessionPickupConnectionlessAllowableValues();
        if (!is_null($session_pickup_connectionless) && !in_array($session_pickup_connectionless, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'session_pickup_connectionless', must be one of '%s'",
                    $session_pickup_connectionless,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['session_pickup_connectionless'] = $session_pickup_connectionless;

        return $this;
    }

    /**
     * Gets session_pickup_expectation
     *
     * @return string|null
     */
    public function getSessionPickupExpectation()
    {
        return $this->container['session_pickup_expectation'];
    }

    /**
     * Sets session_pickup_expectation
     *
     * @param string|null $session_pickup_expectation Enable/disable session helper expectation session sync for FGSP.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSessionPickupExpectation($session_pickup_expectation)
    {
        $allowedValues = $this->getSessionPickupExpectationAllowableValues();
        if (!is_null($session_pickup_expectation) && !in_array($session_pickup_expectation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'session_pickup_expectation', must be one of '%s'",
                    $session_pickup_expectation,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['session_pickup_expectation'] = $session_pickup_expectation;

        return $this;
    }

    /**
     * Gets session_pickup_nat
     *
     * @return string|null
     */
    public function getSessionPickupNat()
    {
        return $this->container['session_pickup_nat'];
    }

    /**
     * Sets session_pickup_nat
     *
     * @param string|null $session_pickup_nat Enable/disable NAT session sync for FGSP.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSessionPickupNat($session_pickup_nat)
    {
        $allowedValues = $this->getSessionPickupNatAllowableValues();
        if (!is_null($session_pickup_nat) && !in_array($session_pickup_nat, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'session_pickup_nat', must be one of '%s'",
                    $session_pickup_nat,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['session_pickup_nat'] = $session_pickup_nat;

        return $this;
    }

    /**
     * Gets session_pickup_delay
     *
     * @return string|null
     */
    public function getSessionPickupDelay()
    {
        return $this->container['session_pickup_delay'];
    }

    /**
     * Sets session_pickup_delay
     *
     * @param string|null $session_pickup_delay Enable to sync sessions longer than 30 sec. Only longer lived sessions need to be synced.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSessionPickupDelay($session_pickup_delay)
    {
        $allowedValues = $this->getSessionPickupDelayAllowableValues();
        if (!is_null($session_pickup_delay) && !in_array($session_pickup_delay, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'session_pickup_delay', must be one of '%s'",
                    $session_pickup_delay,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['session_pickup_delay'] = $session_pickup_delay;

        return $this;
    }

    /**
     * Gets link_failed_signal
     *
     * @return string|null
     */
    public function getLinkFailedSignal()
    {
        return $this->container['link_failed_signal'];
    }

    /**
     * Sets link_failed_signal
     *
     * @param string|null $link_failed_signal Enable to shut down all interfaces for 1 sec after a failover. Use if gratuitous ARPs do not update network.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setLinkFailedSignal($link_failed_signal)
    {
        $allowedValues = $this->getLinkFailedSignalAllowableValues();
        if (!is_null($link_failed_signal) && !in_array($link_failed_signal, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'link_failed_signal', must be one of '%s'",
                    $link_failed_signal,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['link_failed_signal'] = $link_failed_signal;

        return $this;
    }

    /**
     * Gets uninterruptible_upgrade
     *
     * @return string|null
     */
    public function getUninterruptibleUpgrade()
    {
        return $this->container['uninterruptible_upgrade'];
    }

    /**
     * Sets uninterruptible_upgrade
     *
     * @param string|null $uninterruptible_upgrade Enable to upgrade a cluster without blocking network traffic.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setUninterruptibleUpgrade($uninterruptible_upgrade)
    {
        $allowedValues = $this->getUninterruptibleUpgradeAllowableValues();
        if (!is_null($uninterruptible_upgrade) && !in_array($uninterruptible_upgrade, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'uninterruptible_upgrade', must be one of '%s'",
                    $uninterruptible_upgrade,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['uninterruptible_upgrade'] = $uninterruptible_upgrade;

        return $this;
    }

    /**
     * Gets standalone_mgmt_vdom
     *
     * @return string|null
     */
    public function getStandaloneMgmtVdom()
    {
        return $this->container['standalone_mgmt_vdom'];
    }

    /**
     * Sets standalone_mgmt_vdom
     *
     * @param string|null $standalone_mgmt_vdom Enable/disable standalone management VDOM.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setStandaloneMgmtVdom($standalone_mgmt_vdom)
    {
        $allowedValues = $this->getStandaloneMgmtVdomAllowableValues();
        if (!is_null($standalone_mgmt_vdom) && !in_array($standalone_mgmt_vdom, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'standalone_mgmt_vdom', must be one of '%s'",
                    $standalone_mgmt_vdom,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['standalone_mgmt_vdom'] = $standalone_mgmt_vdom;

        return $this;
    }

    /**
     * Gets ha_mgmt_status
     *
     * @return string|null
     */
    public function getHaMgmtStatus()
    {
        return $this->container['ha_mgmt_status'];
    }

    /**
     * Sets ha_mgmt_status
     *
     * @param string|null $ha_mgmt_status Enable to reserve interfaces to manage individual cluster units.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setHaMgmtStatus($ha_mgmt_status)
    {
        $allowedValues = $this->getHaMgmtStatusAllowableValues();
        if (!is_null($ha_mgmt_status) && !in_array($ha_mgmt_status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ha_mgmt_status', must be one of '%s'",
                    $ha_mgmt_status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ha_mgmt_status'] = $ha_mgmt_status;

        return $this;
    }

    /**
     * Gets ha_mgmt_interfaces
     *
     * @return \Fortigate\FortiOS\Model\CMDB\SystemHaHaMgmtInterfaces[]|null
     */
    public function getHaMgmtInterfaces()
    {
        return $this->container['ha_mgmt_interfaces'];
    }

    /**
     * Sets ha_mgmt_interfaces
     *
     * @param \Fortigate\FortiOS\Model\CMDB\SystemHaHaMgmtInterfaces[]|null $ha_mgmt_interfaces Reserve interfaces to manage individual cluster units.
     *
     * @return self
     */
    public function setHaMgmtInterfaces($ha_mgmt_interfaces)
    {

        if (!is_null($ha_mgmt_interfaces) && (count($ha_mgmt_interfaces) > 0)) {
            throw new \InvalidArgumentException('invalid value for $ha_mgmt_interfaces when calling InlineObject319., number of items must be less than or equal to 0.');
        }
        $this->container['ha_mgmt_interfaces'] = $ha_mgmt_interfaces;

        return $this;
    }

    /**
     * Gets ha_eth_type
     *
     * @return string|null
     */
    public function getHaEthType()
    {
        return $this->container['ha_eth_type'];
    }

    /**
     * Sets ha_eth_type
     *
     * @param string|null $ha_eth_type HA heartbeat packet Ethertype (4-digit hex).
     *
     * @return self
     */
    public function setHaEthType($ha_eth_type)
    {
        if (!is_null($ha_eth_type) && (mb_strlen($ha_eth_type) > 4)) {
            throw new \InvalidArgumentException('invalid length for $ha_eth_type when calling InlineObject319., must be smaller than or equal to 4.');
        }

        $this->container['ha_eth_type'] = $ha_eth_type;

        return $this;
    }

    /**
     * Gets hc_eth_type
     *
     * @return string|null
     */
    public function getHcEthType()
    {
        return $this->container['hc_eth_type'];
    }

    /**
     * Sets hc_eth_type
     *
     * @param string|null $hc_eth_type Transparent mode HA heartbeat packet Ethertype (4-digit hex).
     *
     * @return self
     */
    public function setHcEthType($hc_eth_type)
    {
        if (!is_null($hc_eth_type) && (mb_strlen($hc_eth_type) > 4)) {
            throw new \InvalidArgumentException('invalid length for $hc_eth_type when calling InlineObject319., must be smaller than or equal to 4.');
        }

        $this->container['hc_eth_type'] = $hc_eth_type;

        return $this;
    }

    /**
     * Gets l2ep_eth_type
     *
     * @return string|null
     */
    public function getL2epEthType()
    {
        return $this->container['l2ep_eth_type'];
    }

    /**
     * Sets l2ep_eth_type
     *
     * @param string|null $l2ep_eth_type Telnet session HA heartbeat packet Ethertype (4-digit hex).
     *
     * @return self
     */
    public function setL2epEthType($l2ep_eth_type)
    {
        if (!is_null($l2ep_eth_type) && (mb_strlen($l2ep_eth_type) > 4)) {
            throw new \InvalidArgumentException('invalid length for $l2ep_eth_type when calling InlineObject319., must be smaller than or equal to 4.');
        }

        $this->container['l2ep_eth_type'] = $l2ep_eth_type;

        return $this;
    }

    /**
     * Gets ha_uptime_diff_margin
     *
     * @return int|null
     */
    public function getHaUptimeDiffMargin()
    {
        return $this->container['ha_uptime_diff_margin'];
    }

    /**
     * Sets ha_uptime_diff_margin
     *
     * @param int|null $ha_uptime_diff_margin Normally you would only reduce this value for failover testing.
     *
     * @return self
     */
    public function setHaUptimeDiffMargin($ha_uptime_diff_margin)
    {

        if (!is_null($ha_uptime_diff_margin) && ($ha_uptime_diff_margin > 65535)) {
            throw new \InvalidArgumentException('invalid value for $ha_uptime_diff_margin when calling InlineObject319., must be smaller than or equal to 65535.');
        }
        if (!is_null($ha_uptime_diff_margin) && ($ha_uptime_diff_margin < 1)) {
            throw new \InvalidArgumentException('invalid value for $ha_uptime_diff_margin when calling InlineObject319., must be bigger than or equal to 1.');
        }

        $this->container['ha_uptime_diff_margin'] = $ha_uptime_diff_margin;

        return $this;
    }

    /**
     * Gets standalone_config_sync
     *
     * @return string|null
     */
    public function getStandaloneConfigSync()
    {
        return $this->container['standalone_config_sync'];
    }

    /**
     * Sets standalone_config_sync
     *
     * @param string|null $standalone_config_sync Enable/disable FGSP configuration synchronization.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setStandaloneConfigSync($standalone_config_sync)
    {
        $allowedValues = $this->getStandaloneConfigSyncAllowableValues();
        if (!is_null($standalone_config_sync) && !in_array($standalone_config_sync, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'standalone_config_sync', must be one of '%s'",
                    $standalone_config_sync,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['standalone_config_sync'] = $standalone_config_sync;

        return $this;
    }

    /**
     * Gets logical_sn
     *
     * @return string|null
     */
    public function getLogicalSn()
    {
        return $this->container['logical_sn'];
    }

    /**
     * Sets logical_sn
     *
     * @param string|null $logical_sn Enable/disable usage of the logical serial number.    enable:Enable usage of the logical serial number.    disable:Disable usage of the logical serial number.
     *
     * @return self
     */
    public function setLogicalSn($logical_sn)
    {
        $allowedValues = $this->getLogicalSnAllowableValues();
        if (!is_null($logical_sn) && !in_array($logical_sn, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'logical_sn', must be one of '%s'",
                    $logical_sn,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['logical_sn'] = $logical_sn;

        return $this;
    }

    /**
     * Gets vcluster_id
     *
     * @return int|null
     */
    public function getVclusterId()
    {
        return $this->container['vcluster_id'];
    }

    /**
     * Sets vcluster_id
     *
     * @param int|null $vcluster_id Cluster ID.
     *
     * @return self
     */
    public function setVclusterId($vcluster_id)
    {

        if (!is_null($vcluster_id) && ($vcluster_id > 255)) {
            throw new \InvalidArgumentException('invalid value for $vcluster_id when calling InlineObject319., must be smaller than or equal to 255.');
        }
        if (!is_null($vcluster_id) && ($vcluster_id < 0)) {
            throw new \InvalidArgumentException('invalid value for $vcluster_id when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['vcluster_id'] = $vcluster_id;

        return $this;
    }

    /**
     * Gets override
     *
     * @return string|null
     */
    public function getOverride()
    {
        return $this->container['override'];
    }

    /**
     * Sets override
     *
     * @param string|null $override Enable and increase the priority of the unit that should always be primary.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setOverride($override)
    {
        $allowedValues = $this->getOverrideAllowableValues();
        if (!is_null($override) && !in_array($override, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'override', must be one of '%s'",
                    $override,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['override'] = $override;

        return $this;
    }

    /**
     * Gets priority
     *
     * @return int|null
     */
    public function getPriority()
    {
        return $this->container['priority'];
    }

    /**
     * Sets priority
     *
     * @param int|null $priority Increase the priority to select the primary unit (0 - 255).
     *
     * @return self
     */
    public function setPriority($priority)
    {

        if (!is_null($priority) && ($priority > 255)) {
            throw new \InvalidArgumentException('invalid value for $priority when calling InlineObject319., must be smaller than or equal to 255.');
        }
        if (!is_null($priority) && ($priority < 0)) {
            throw new \InvalidArgumentException('invalid value for $priority when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['priority'] = $priority;

        return $this;
    }

    /**
     * Gets override_wait_time
     *
     * @return int|null
     */
    public function getOverrideWaitTime()
    {
        return $this->container['override_wait_time'];
    }

    /**
     * Sets override_wait_time
     *
     * @param int|null $override_wait_time Delay negotiating if override is enabled (0 - 3600 sec). Reduces how often the cluster negotiates.
     *
     * @return self
     */
    public function setOverrideWaitTime($override_wait_time)
    {

        if (!is_null($override_wait_time) && ($override_wait_time > 3600)) {
            throw new \InvalidArgumentException('invalid value for $override_wait_time when calling InlineObject319., must be smaller than or equal to 3600.');
        }
        if (!is_null($override_wait_time) && ($override_wait_time < 0)) {
            throw new \InvalidArgumentException('invalid value for $override_wait_time when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['override_wait_time'] = $override_wait_time;

        return $this;
    }

    /**
     * Gets schedule
     *
     * @return string|null
     */
    public function getSchedule()
    {
        return $this->container['schedule'];
    }

    /**
     * Sets schedule
     *
     * @param string|null $schedule Type of A-A load balancing. Use none if you have external load balancers.    none:None.    hub:Hub.    leastconnection:Least connection.    round-robin:Round robin.    weight-round-robin:Weight round robin.    random:Random.    ip:IP.    ipport:IP port.
     *
     * @return self
     */
    public function setSchedule($schedule)
    {
        $allowedValues = $this->getScheduleAllowableValues();
        if (!is_null($schedule) && !in_array($schedule, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'schedule', must be one of '%s'",
                    $schedule,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['schedule'] = $schedule;

        return $this;
    }

    /**
     * Gets weight
     *
     * @return string|null
     */
    public function getWeight()
    {
        return $this->container['weight'];
    }

    /**
     * Sets weight
     *
     * @param string|null $weight Weight-round-robin weight for each cluster unit. Syntax <priority> <weight>.
     *
     * @return self
     */
    public function setWeight($weight)
    {
        $this->container['weight'] = $weight;

        return $this;
    }

    /**
     * Gets cpu_threshold
     *
     * @return string|null
     */
    public function getCpuThreshold()
    {
        return $this->container['cpu_threshold'];
    }

    /**
     * Sets cpu_threshold
     *
     * @param string|null $cpu_threshold Dynamic weighted load balancing CPU usage weight and high and low thresholds.
     *
     * @return self
     */
    public function setCpuThreshold($cpu_threshold)
    {
        $this->container['cpu_threshold'] = $cpu_threshold;

        return $this;
    }

    /**
     * Gets memory_threshold
     *
     * @return string|null
     */
    public function getMemoryThreshold()
    {
        return $this->container['memory_threshold'];
    }

    /**
     * Sets memory_threshold
     *
     * @param string|null $memory_threshold Dynamic weighted load balancing memory usage weight and high and low thresholds.
     *
     * @return self
     */
    public function setMemoryThreshold($memory_threshold)
    {
        $this->container['memory_threshold'] = $memory_threshold;

        return $this;
    }

    /**
     * Gets http_proxy_threshold
     *
     * @return string|null
     */
    public function getHttpProxyThreshold()
    {
        return $this->container['http_proxy_threshold'];
    }

    /**
     * Sets http_proxy_threshold
     *
     * @param string|null $http_proxy_threshold Dynamic weighted load balancing weight and high and low number of HTTP proxy sessions.
     *
     * @return self
     */
    public function setHttpProxyThreshold($http_proxy_threshold)
    {
        $this->container['http_proxy_threshold'] = $http_proxy_threshold;

        return $this;
    }

    /**
     * Gets ftp_proxy_threshold
     *
     * @return string|null
     */
    public function getFtpProxyThreshold()
    {
        return $this->container['ftp_proxy_threshold'];
    }

    /**
     * Sets ftp_proxy_threshold
     *
     * @param string|null $ftp_proxy_threshold Dynamic weighted load balancing weight and high and low number of FTP proxy sessions.
     *
     * @return self
     */
    public function setFtpProxyThreshold($ftp_proxy_threshold)
    {
        $this->container['ftp_proxy_threshold'] = $ftp_proxy_threshold;

        return $this;
    }

    /**
     * Gets imap_proxy_threshold
     *
     * @return string|null
     */
    public function getImapProxyThreshold()
    {
        return $this->container['imap_proxy_threshold'];
    }

    /**
     * Sets imap_proxy_threshold
     *
     * @param string|null $imap_proxy_threshold Dynamic weighted load balancing weight and high and low number of IMAP proxy sessions.
     *
     * @return self
     */
    public function setImapProxyThreshold($imap_proxy_threshold)
    {
        $this->container['imap_proxy_threshold'] = $imap_proxy_threshold;

        return $this;
    }

    /**
     * Gets nntp_proxy_threshold
     *
     * @return string|null
     */
    public function getNntpProxyThreshold()
    {
        return $this->container['nntp_proxy_threshold'];
    }

    /**
     * Sets nntp_proxy_threshold
     *
     * @param string|null $nntp_proxy_threshold Dynamic weighted load balancing weight and high and low number of NNTP proxy sessions.
     *
     * @return self
     */
    public function setNntpProxyThreshold($nntp_proxy_threshold)
    {
        $this->container['nntp_proxy_threshold'] = $nntp_proxy_threshold;

        return $this;
    }

    /**
     * Gets pop3_proxy_threshold
     *
     * @return string|null
     */
    public function getPop3ProxyThreshold()
    {
        return $this->container['pop3_proxy_threshold'];
    }

    /**
     * Sets pop3_proxy_threshold
     *
     * @param string|null $pop3_proxy_threshold Dynamic weighted load balancing weight and high and low number of POP3 proxy sessions.
     *
     * @return self
     */
    public function setPop3ProxyThreshold($pop3_proxy_threshold)
    {
        $this->container['pop3_proxy_threshold'] = $pop3_proxy_threshold;

        return $this;
    }

    /**
     * Gets smtp_proxy_threshold
     *
     * @return string|null
     */
    public function getSmtpProxyThreshold()
    {
        return $this->container['smtp_proxy_threshold'];
    }

    /**
     * Sets smtp_proxy_threshold
     *
     * @param string|null $smtp_proxy_threshold Dynamic weighted load balancing weight and high and low number of SMTP proxy sessions.
     *
     * @return self
     */
    public function setSmtpProxyThreshold($smtp_proxy_threshold)
    {
        $this->container['smtp_proxy_threshold'] = $smtp_proxy_threshold;

        return $this;
    }

    /**
     * Gets monitor
     *
     * @return string|null
     */
    public function getMonitor()
    {
        return $this->container['monitor'];
    }

    /**
     * Sets monitor
     *
     * @param string|null $monitor Interfaces to check for port monitoring (or link failure).
     *
     * @return self
     */
    public function setMonitor($monitor)
    {
        $this->container['monitor'] = $monitor;

        return $this;
    }

    /**
     * Gets pingserver_monitor_interface
     *
     * @return string|null
     */
    public function getPingserverMonitorInterface()
    {
        return $this->container['pingserver_monitor_interface'];
    }

    /**
     * Sets pingserver_monitor_interface
     *
     * @param string|null $pingserver_monitor_interface Interfaces to check for remote IP monitoring.
     *
     * @return self
     */
    public function setPingserverMonitorInterface($pingserver_monitor_interface)
    {
        $this->container['pingserver_monitor_interface'] = $pingserver_monitor_interface;

        return $this;
    }

    /**
     * Gets pingserver_failover_threshold
     *
     * @return int|null
     */
    public function getPingserverFailoverThreshold()
    {
        return $this->container['pingserver_failover_threshold'];
    }

    /**
     * Sets pingserver_failover_threshold
     *
     * @param int|null $pingserver_failover_threshold Remote IP monitoring failover threshold (0 - 50).
     *
     * @return self
     */
    public function setPingserverFailoverThreshold($pingserver_failover_threshold)
    {

        if (!is_null($pingserver_failover_threshold) && ($pingserver_failover_threshold > 50)) {
            throw new \InvalidArgumentException('invalid value for $pingserver_failover_threshold when calling InlineObject319., must be smaller than or equal to 50.');
        }
        if (!is_null($pingserver_failover_threshold) && ($pingserver_failover_threshold < 0)) {
            throw new \InvalidArgumentException('invalid value for $pingserver_failover_threshold when calling InlineObject319., must be bigger than or equal to 0.');
        }

        $this->container['pingserver_failover_threshold'] = $pingserver_failover_threshold;

        return $this;
    }

    /**
     * Gets pingserver_secondary_force_reset
     *
     * @return string|null
     */
    public function getPingserverSecondaryForceReset()
    {
        return $this->container['pingserver_secondary_force_reset'];
    }

    /**
     * Sets pingserver_secondary_force_reset
     *
     * @param string|null $pingserver_secondary_force_reset Enable to force the cluster to negotiate after a remote IP monitoring failover.    enable:Enable force reset of secondary after PING server failure.    disable:Disable force reset of secondary after PING server failure.
     *
     * @return self
     */
    public function setPingserverSecondaryForceReset($pingserver_secondary_force_reset)
    {
        $allowedValues = $this->getPingserverSecondaryForceResetAllowableValues();
        if (!is_null($pingserver_secondary_force_reset) && !in_array($pingserver_secondary_force_reset, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'pingserver_secondary_force_reset', must be one of '%s'",
                    $pingserver_secondary_force_reset,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['pingserver_secondary_force_reset'] = $pingserver_secondary_force_reset;

        return $this;
    }

    /**
     * Gets pingserver_flip_timeout
     *
     * @return int|null
     */
    public function getPingserverFlipTimeout()
    {
        return $this->container['pingserver_flip_timeout'];
    }

    /**
     * Sets pingserver_flip_timeout
     *
     * @param int|null $pingserver_flip_timeout Time to wait in minutes before renegotiating after a remote IP monitoring failover.
     *
     * @return self
     */
    public function setPingserverFlipTimeout($pingserver_flip_timeout)
    {

        if (!is_null($pingserver_flip_timeout) && ($pingserver_flip_timeout > 2147483647)) {
            throw new \InvalidArgumentException('invalid value for $pingserver_flip_timeout when calling InlineObject319., must be smaller than or equal to 2147483647.');
        }
        if (!is_null($pingserver_flip_timeout) && ($pingserver_flip_timeout < 6)) {
            throw new \InvalidArgumentException('invalid value for $pingserver_flip_timeout when calling InlineObject319., must be bigger than or equal to 6.');
        }

        $this->container['pingserver_flip_timeout'] = $pingserver_flip_timeout;

        return $this;
    }

    /**
     * Gets vdom
     *
     * @return string|null
     */
    public function getVdom()
    {
        return $this->container['vdom'];
    }

    /**
     * Sets vdom
     *
     * @param string|null $vdom VDOMs in virtual cluster 1.
     *
     * @return self
     */
    public function setVdom($vdom)
    {
        $this->container['vdom'] = $vdom;

        return $this;
    }

    /**
     * Gets vcluster2
     *
     * @return string|null
     */
    public function getVcluster2()
    {
        return $this->container['vcluster2'];
    }

    /**
     * Sets vcluster2
     *
     * @param string|null $vcluster2 Enable/disable virtual cluster 2 for virtual clustering.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setVcluster2($vcluster2)
    {
        $allowedValues = $this->getVcluster2AllowableValues();
        if (!is_null($vcluster2) && !in_array($vcluster2, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'vcluster2', must be one of '%s'",
                    $vcluster2,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['vcluster2'] = $vcluster2;

        return $this;
    }

    /**
     * Gets secondary_vcluster
     *
     * @return \Fortigate\FortiOS\Model\CMDB\SystemHaSecondaryVcluster[]|null
     */
    public function getSecondaryVcluster()
    {
        return $this->container['secondary_vcluster'];
    }

    /**
     * Sets secondary_vcluster
     *
     * @param \Fortigate\FortiOS\Model\CMDB\SystemHaSecondaryVcluster[]|null $secondary_vcluster Configure virtual cluster 2.
     *
     * @return self
     */
    public function setSecondaryVcluster($secondary_vcluster)
    {

        if (!is_null($secondary_vcluster) && (count($secondary_vcluster) > 0)) {
            throw new \InvalidArgumentException('invalid value for $secondary_vcluster when calling InlineObject319., number of items must be less than or equal to 0.');
        }
        $this->container['secondary_vcluster'] = $secondary_vcluster;

        return $this;
    }

    /**
     * Gets ha_direct
     *
     * @return string|null
     */
    public function getHaDirect()
    {
        return $this->container['ha_direct'];
    }

    /**
     * Sets ha_direct
     *
     * @param string|null $ha_direct Enable/disable using ha-mgmt interface for syslog, SNMP, remote authentication (RADIUS), FortiAnalyzer, FortiSandbox, sFlow, and Netflow.    enable:Enable using ha-mgmt interface for syslog, SNMP, remote authentication (RADIUS), FortiAnalyzer, FortiManager, FortiSandbox, sFlow, and Netflow.    disable:Disable using ha-mgmt interface for syslog, SNMP, remote authentication (RADIUS), FortiAnalyzer, FortiManager, FortiSandbox, sFlow, and Netflow.
     *
     * @return self
     */
    public function setHaDirect($ha_direct)
    {
        $allowedValues = $this->getHaDirectAllowableValues();
        if (!is_null($ha_direct) && !in_array($ha_direct, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ha_direct', must be one of '%s'",
                    $ha_direct,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ha_direct'] = $ha_direct;

        return $this;
    }

    /**
     * Gets ssd_failover
     *
     * @return string|null
     */
    public function getSsdFailover()
    {
        return $this->container['ssd_failover'];
    }

    /**
     * Sets ssd_failover
     *
     * @param string|null $ssd_failover Enable/disable automatic HA failover on SSD disk failure.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSsdFailover($ssd_failover)
    {
        $allowedValues = $this->getSsdFailoverAllowableValues();
        if (!is_null($ssd_failover) && !in_array($ssd_failover, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ssd_failover', must be one of '%s'",
                    $ssd_failover,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ssd_failover'] = $ssd_failover;

        return $this;
    }

    /**
     * Gets memory_compatible_mode
     *
     * @return string|null
     */
    public function getMemoryCompatibleMode()
    {
        return $this->container['memory_compatible_mode'];
    }

    /**
     * Sets memory_compatible_mode
     *
     * @param string|null $memory_compatible_mode Enable/disable memory compatible mode.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setMemoryCompatibleMode($memory_compatible_mode)
    {
        $allowedValues = $this->getMemoryCompatibleModeAllowableValues();
        if (!is_null($memory_compatible_mode) && !in_array($memory_compatible_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'memory_compatible_mode', must be one of '%s'",
                    $memory_compatible_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['memory_compatible_mode'] = $memory_compatible_mode;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


