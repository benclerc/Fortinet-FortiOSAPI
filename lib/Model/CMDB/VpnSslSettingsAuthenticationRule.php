<?php
/**
 * VpnSslSettingsAuthenticationRule
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * VpnSslSettingsAuthenticationRule Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class VpnSslSettingsAuthenticationRule implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = '_vpn_ssl_settings_authentication_rule';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'int',
        'source_interface' => '\Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceInterface[]',
        'source_address' => '\Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]',
        'source_address_negate' => 'string',
        'source_address6' => '\Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceAddress6[]',
        'source_address6_negate' => 'string',
        'users' => '\Fortigate\FortiOS\Model\CMDB\SystemSdwanUsers[]',
        'groups' => '\Fortigate\FortiOS\Model\CMDB\SwitchControllerSecurityPolicy8021XNameUserGroup[]',
        'portal' => 'string',
        'realm' => 'string',
        'client_cert' => 'string',
        'user_peer' => 'string',
        'cipher' => 'string',
        'auth' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => null,
        'source_interface' => null,
        'source_address' => null,
        'source_address_negate' => null,
        'source_address6' => null,
        'source_address6_negate' => null,
        'users' => null,
        'groups' => null,
        'portal' => null,
        'realm' => null,
        'client_cert' => null,
        'user_peer' => null,
        'cipher' => null,
        'auth' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'source_interface' => 'source-interface',
        'source_address' => 'source-address',
        'source_address_negate' => 'source-address-negate',
        'source_address6' => 'source-address6',
        'source_address6_negate' => 'source-address6-negate',
        'users' => 'users',
        'groups' => 'groups',
        'portal' => 'portal',
        'realm' => 'realm',
        'client_cert' => 'client-cert',
        'user_peer' => 'user-peer',
        'cipher' => 'cipher',
        'auth' => 'auth'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'source_interface' => 'setSourceInterface',
        'source_address' => 'setSourceAddress',
        'source_address_negate' => 'setSourceAddressNegate',
        'source_address6' => 'setSourceAddress6',
        'source_address6_negate' => 'setSourceAddress6Negate',
        'users' => 'setUsers',
        'groups' => 'setGroups',
        'portal' => 'setPortal',
        'realm' => 'setRealm',
        'client_cert' => 'setClientCert',
        'user_peer' => 'setUserPeer',
        'cipher' => 'setCipher',
        'auth' => 'setAuth'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'source_interface' => 'getSourceInterface',
        'source_address' => 'getSourceAddress',
        'source_address_negate' => 'getSourceAddressNegate',
        'source_address6' => 'getSourceAddress6',
        'source_address6_negate' => 'getSourceAddress6Negate',
        'users' => 'getUsers',
        'groups' => 'getGroups',
        'portal' => 'getPortal',
        'realm' => 'getRealm',
        'client_cert' => 'getClientCert',
        'user_peer' => 'getUserPeer',
        'cipher' => 'getCipher',
        'auth' => 'getAuth'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const SOURCE_ADDRESS_NEGATE_ENABLE = 'enable';
    const SOURCE_ADDRESS_NEGATE_DISABLE = 'disable';
    const SOURCE_ADDRESS6_NEGATE_ENABLE = 'enable';
    const SOURCE_ADDRESS6_NEGATE_DISABLE = 'disable';
    const CLIENT_CERT_ENABLE = 'enable';
    const CLIENT_CERT_DISABLE = 'disable';
    const CIPHER_ANY = 'any';
    const CIPHER_HIGH = 'high';
    const CIPHER_MEDIUM = 'medium';
    const AUTH_ANY = 'any';
    const AUTH_LOCAL = 'local';
    const AUTH_RADIUS = 'radius';
    const AUTH_TACACS = 'tacacs+';
    const AUTH_LDAP = 'ldap';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSourceAddressNegateAllowableValues()
    {
        return [
            self::SOURCE_ADDRESS_NEGATE_ENABLE,
            self::SOURCE_ADDRESS_NEGATE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSourceAddress6NegateAllowableValues()
    {
        return [
            self::SOURCE_ADDRESS6_NEGATE_ENABLE,
            self::SOURCE_ADDRESS6_NEGATE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getClientCertAllowableValues()
    {
        return [
            self::CLIENT_CERT_ENABLE,
            self::CLIENT_CERT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCipherAllowableValues()
    {
        return [
            self::CIPHER_ANY,
            self::CIPHER_HIGH,
            self::CIPHER_MEDIUM,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthAllowableValues()
    {
        return [
            self::AUTH_ANY,
            self::AUTH_LOCAL,
            self::AUTH_RADIUS,
            self::AUTH_TACACS,
            self::AUTH_LDAP,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = $data['id'] ?? null;
        $this->container['source_interface'] = $data['source_interface'] ?? null;
        $this->container['source_address'] = $data['source_address'] ?? null;
        $this->container['source_address_negate'] = $data['source_address_negate'] ?? null;
        $this->container['source_address6'] = $data['source_address6'] ?? null;
        $this->container['source_address6_negate'] = $data['source_address6_negate'] ?? null;
        $this->container['users'] = $data['users'] ?? null;
        $this->container['groups'] = $data['groups'] ?? null;
        $this->container['portal'] = $data['portal'] ?? null;
        $this->container['realm'] = $data['realm'] ?? null;
        $this->container['client_cert'] = $data['client_cert'] ?? null;
        $this->container['user_peer'] = $data['user_peer'] ?? null;
        $this->container['cipher'] = $data['cipher'] ?? null;
        $this->container['auth'] = $data['auth'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['id']) && ($this->container['id'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'id', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['id']) && ($this->container['id'] < 0)) {
            $invalidProperties[] = "invalid value for 'id', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['source_interface']) && (count($this->container['source_interface']) > 0)) {
            $invalidProperties[] = "invalid value for 'source_interface', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['source_address']) && (count($this->container['source_address']) > 0)) {
            $invalidProperties[] = "invalid value for 'source_address', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getSourceAddressNegateAllowableValues();
        if (!is_null($this->container['source_address_negate']) && !in_array($this->container['source_address_negate'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'source_address_negate', must be one of '%s'",
                $this->container['source_address_negate'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['source_address6']) && (count($this->container['source_address6']) > 0)) {
            $invalidProperties[] = "invalid value for 'source_address6', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getSourceAddress6NegateAllowableValues();
        if (!is_null($this->container['source_address6_negate']) && !in_array($this->container['source_address6_negate'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'source_address6_negate', must be one of '%s'",
                $this->container['source_address6_negate'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['users']) && (count($this->container['users']) > 0)) {
            $invalidProperties[] = "invalid value for 'users', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['groups']) && (count($this->container['groups']) > 0)) {
            $invalidProperties[] = "invalid value for 'groups', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['portal']) && (mb_strlen($this->container['portal']) > 35)) {
            $invalidProperties[] = "invalid value for 'portal', the character length must be smaller than or equal to 35.";
        }

        if (!is_null($this->container['realm']) && (mb_strlen($this->container['realm']) > 35)) {
            $invalidProperties[] = "invalid value for 'realm', the character length must be smaller than or equal to 35.";
        }

        $allowedValues = $this->getClientCertAllowableValues();
        if (!is_null($this->container['client_cert']) && !in_array($this->container['client_cert'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'client_cert', must be one of '%s'",
                $this->container['client_cert'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['user_peer']) && (mb_strlen($this->container['user_peer']) > 35)) {
            $invalidProperties[] = "invalid value for 'user_peer', the character length must be smaller than or equal to 35.";
        }

        $allowedValues = $this->getCipherAllowableValues();
        if (!is_null($this->container['cipher']) && !in_array($this->container['cipher'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'cipher', must be one of '%s'",
                $this->container['cipher'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthAllowableValues();
        if (!is_null($this->container['auth']) && !in_array($this->container['auth'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth', must be one of '%s'",
                $this->container['auth'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id ID (0 - 4294967295).
     *
     * @return self
     */
    public function setId($id)
    {

        if (!is_null($id) && ($id > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $id when calling VpnSslSettingsAuthenticationRule., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($id) && ($id < 0)) {
            throw new \InvalidArgumentException('invalid value for $id when calling VpnSslSettingsAuthenticationRule., must be bigger than or equal to 0.');
        }

        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets source_interface
     *
     * @return \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceInterface[]|null
     */
    public function getSourceInterface()
    {
        return $this->container['source_interface'];
    }

    /**
     * Sets source_interface
     *
     * @param \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceInterface[]|null $source_interface SSL VPN source interface of incoming traffic.
     *
     * @return self
     */
    public function setSourceInterface($source_interface)
    {

        if (!is_null($source_interface) && (count($source_interface) > 0)) {
            throw new \InvalidArgumentException('invalid value for $source_interface when calling VpnSslSettingsAuthenticationRule., number of items must be less than or equal to 0.');
        }
        $this->container['source_interface'] = $source_interface;

        return $this;
    }

    /**
     * Gets source_address
     *
     * @return \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null
     */
    public function getSourceAddress()
    {
        return $this->container['source_address'];
    }

    /**
     * Sets source_address
     *
     * @param \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null $source_address Source address of incoming traffic.
     *
     * @return self
     */
    public function setSourceAddress($source_address)
    {

        if (!is_null($source_address) && (count($source_address) > 0)) {
            throw new \InvalidArgumentException('invalid value for $source_address when calling VpnSslSettingsAuthenticationRule., number of items must be less than or equal to 0.');
        }
        $this->container['source_address'] = $source_address;

        return $this;
    }

    /**
     * Gets source_address_negate
     *
     * @return string|null
     */
    public function getSourceAddressNegate()
    {
        return $this->container['source_address_negate'];
    }

    /**
     * Sets source_address_negate
     *
     * @param string|null $source_address_negate Enable/disable negated source address match.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSourceAddressNegate($source_address_negate)
    {
        $allowedValues = $this->getSourceAddressNegateAllowableValues();
        if (!is_null($source_address_negate) && !in_array($source_address_negate, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'source_address_negate', must be one of '%s'",
                    $source_address_negate,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['source_address_negate'] = $source_address_negate;

        return $this;
    }

    /**
     * Gets source_address6
     *
     * @return \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceAddress6[]|null
     */
    public function getSourceAddress6()
    {
        return $this->container['source_address6'];
    }

    /**
     * Sets source_address6
     *
     * @param \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceAddress6[]|null $source_address6 IPv6 source address of incoming traffic.
     *
     * @return self
     */
    public function setSourceAddress6($source_address6)
    {

        if (!is_null($source_address6) && (count($source_address6) > 0)) {
            throw new \InvalidArgumentException('invalid value for $source_address6 when calling VpnSslSettingsAuthenticationRule., number of items must be less than or equal to 0.');
        }
        $this->container['source_address6'] = $source_address6;

        return $this;
    }

    /**
     * Gets source_address6_negate
     *
     * @return string|null
     */
    public function getSourceAddress6Negate()
    {
        return $this->container['source_address6_negate'];
    }

    /**
     * Sets source_address6_negate
     *
     * @param string|null $source_address6_negate Enable/disable negated source IPv6 address match.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSourceAddress6Negate($source_address6_negate)
    {
        $allowedValues = $this->getSourceAddress6NegateAllowableValues();
        if (!is_null($source_address6_negate) && !in_array($source_address6_negate, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'source_address6_negate', must be one of '%s'",
                    $source_address6_negate,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['source_address6_negate'] = $source_address6_negate;

        return $this;
    }

    /**
     * Gets users
     *
     * @return \Fortigate\FortiOS\Model\CMDB\SystemSdwanUsers[]|null
     */
    public function getUsers()
    {
        return $this->container['users'];
    }

    /**
     * Sets users
     *
     * @param \Fortigate\FortiOS\Model\CMDB\SystemSdwanUsers[]|null $users User name.
     *
     * @return self
     */
    public function setUsers($users)
    {

        if (!is_null($users) && (count($users) > 0)) {
            throw new \InvalidArgumentException('invalid value for $users when calling VpnSslSettingsAuthenticationRule., number of items must be less than or equal to 0.');
        }
        $this->container['users'] = $users;

        return $this;
    }

    /**
     * Gets groups
     *
     * @return \Fortigate\FortiOS\Model\CMDB\SwitchControllerSecurityPolicy8021XNameUserGroup[]|null
     */
    public function getGroups()
    {
        return $this->container['groups'];
    }

    /**
     * Sets groups
     *
     * @param \Fortigate\FortiOS\Model\CMDB\SwitchControllerSecurityPolicy8021XNameUserGroup[]|null $groups User groups.
     *
     * @return self
     */
    public function setGroups($groups)
    {

        if (!is_null($groups) && (count($groups) > 0)) {
            throw new \InvalidArgumentException('invalid value for $groups when calling VpnSslSettingsAuthenticationRule., number of items must be less than or equal to 0.');
        }
        $this->container['groups'] = $groups;

        return $this;
    }

    /**
     * Gets portal
     *
     * @return string|null
     */
    public function getPortal()
    {
        return $this->container['portal'];
    }

    /**
     * Sets portal
     *
     * @param string|null $portal SSL VPN portal.
     *
     * @return self
     */
    public function setPortal($portal)
    {
        if (!is_null($portal) && (mb_strlen($portal) > 35)) {
            throw new \InvalidArgumentException('invalid length for $portal when calling VpnSslSettingsAuthenticationRule., must be smaller than or equal to 35.');
        }

        $this->container['portal'] = $portal;

        return $this;
    }

    /**
     * Gets realm
     *
     * @return string|null
     */
    public function getRealm()
    {
        return $this->container['realm'];
    }

    /**
     * Sets realm
     *
     * @param string|null $realm SSL VPN realm.
     *
     * @return self
     */
    public function setRealm($realm)
    {
        if (!is_null($realm) && (mb_strlen($realm) > 35)) {
            throw new \InvalidArgumentException('invalid length for $realm when calling VpnSslSettingsAuthenticationRule., must be smaller than or equal to 35.');
        }

        $this->container['realm'] = $realm;

        return $this;
    }

    /**
     * Gets client_cert
     *
     * @return string|null
     */
    public function getClientCert()
    {
        return $this->container['client_cert'];
    }

    /**
     * Sets client_cert
     *
     * @param string|null $client_cert Enable/disable SSL VPN client certificate restrictive.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setClientCert($client_cert)
    {
        $allowedValues = $this->getClientCertAllowableValues();
        if (!is_null($client_cert) && !in_array($client_cert, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'client_cert', must be one of '%s'",
                    $client_cert,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['client_cert'] = $client_cert;

        return $this;
    }

    /**
     * Gets user_peer
     *
     * @return string|null
     */
    public function getUserPeer()
    {
        return $this->container['user_peer'];
    }

    /**
     * Sets user_peer
     *
     * @param string|null $user_peer Name of user peer.
     *
     * @return self
     */
    public function setUserPeer($user_peer)
    {
        if (!is_null($user_peer) && (mb_strlen($user_peer) > 35)) {
            throw new \InvalidArgumentException('invalid length for $user_peer when calling VpnSslSettingsAuthenticationRule., must be smaller than or equal to 35.');
        }

        $this->container['user_peer'] = $user_peer;

        return $this;
    }

    /**
     * Gets cipher
     *
     * @return string|null
     */
    public function getCipher()
    {
        return $this->container['cipher'];
    }

    /**
     * Sets cipher
     *
     * @param string|null $cipher SSL VPN cipher strength.    any:Any cipher strength.    high:High cipher strength (>= 168 bits).    medium:Medium cipher strength (>= 128 bits).
     *
     * @return self
     */
    public function setCipher($cipher)
    {
        $allowedValues = $this->getCipherAllowableValues();
        if (!is_null($cipher) && !in_array($cipher, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'cipher', must be one of '%s'",
                    $cipher,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cipher'] = $cipher;

        return $this;
    }

    /**
     * Gets auth
     *
     * @return string|null
     */
    public function getAuth()
    {
        return $this->container['auth'];
    }

    /**
     * Sets auth
     *
     * @param string|null $auth SSL VPN authentication method restriction.    any:Any    local:Local    radius:RADIUS    tacacs+:TACACS+    ldap:LDAP
     *
     * @return self
     */
    public function setAuth($auth)
    {
        $allowedValues = $this->getAuthAllowableValues();
        if (!is_null($auth) && !in_array($auth, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth', must be one of '%s'",
                    $auth,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth'] = $auth;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


