<?php
/**
 * InlineObject412
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * InlineObject412 Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class InlineObject412 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'inline_object_412';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'service_id' => 'string',
        'router_id' => 'string',
        'cache_id' => 'string',
        'group_address' => 'string',
        'server_list' => 'string',
        'router_list' => 'string',
        'ports_defined' => 'string',
        'server_type' => 'string',
        'ports' => 'string',
        'authentication' => 'string',
        'password' => 'string',
        'forward_method' => 'string',
        'cache_engine_method' => 'string',
        'service_type' => 'string',
        'primary_hash' => 'string',
        'priority' => 'int',
        'protocol' => 'int',
        'assignment_weight' => 'int',
        'assignment_bucket_format' => 'string',
        'return_method' => 'string',
        'assignment_method' => 'string',
        'assignment_srcaddr_mask' => 'string',
        'assignment_dstaddr_mask' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'service_id' => null,
        'router_id' => 'ipv4',
        'cache_id' => 'ipv4',
        'group_address' => null,
        'server_list' => null,
        'router_list' => null,
        'ports_defined' => null,
        'server_type' => null,
        'ports' => null,
        'authentication' => null,
        'password' => 'password',
        'forward_method' => null,
        'cache_engine_method' => null,
        'service_type' => null,
        'primary_hash' => null,
        'priority' => null,
        'protocol' => null,
        'assignment_weight' => null,
        'assignment_bucket_format' => null,
        'return_method' => null,
        'assignment_method' => null,
        'assignment_srcaddr_mask' => null,
        'assignment_dstaddr_mask' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'service_id' => 'service-id',
        'router_id' => 'router-id',
        'cache_id' => 'cache-id',
        'group_address' => 'group-address',
        'server_list' => 'server-list',
        'router_list' => 'router-list',
        'ports_defined' => 'ports-defined',
        'server_type' => 'server-type',
        'ports' => 'ports',
        'authentication' => 'authentication',
        'password' => 'password',
        'forward_method' => 'forward-method',
        'cache_engine_method' => 'cache-engine-method',
        'service_type' => 'service-type',
        'primary_hash' => 'primary-hash',
        'priority' => 'priority',
        'protocol' => 'protocol',
        'assignment_weight' => 'assignment-weight',
        'assignment_bucket_format' => 'assignment-bucket-format',
        'return_method' => 'return-method',
        'assignment_method' => 'assignment-method',
        'assignment_srcaddr_mask' => 'assignment-srcaddr-mask',
        'assignment_dstaddr_mask' => 'assignment-dstaddr-mask'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'service_id' => 'setServiceId',
        'router_id' => 'setRouterId',
        'cache_id' => 'setCacheId',
        'group_address' => 'setGroupAddress',
        'server_list' => 'setServerList',
        'router_list' => 'setRouterList',
        'ports_defined' => 'setPortsDefined',
        'server_type' => 'setServerType',
        'ports' => 'setPorts',
        'authentication' => 'setAuthentication',
        'password' => 'setPassword',
        'forward_method' => 'setForwardMethod',
        'cache_engine_method' => 'setCacheEngineMethod',
        'service_type' => 'setServiceType',
        'primary_hash' => 'setPrimaryHash',
        'priority' => 'setPriority',
        'protocol' => 'setProtocol',
        'assignment_weight' => 'setAssignmentWeight',
        'assignment_bucket_format' => 'setAssignmentBucketFormat',
        'return_method' => 'setReturnMethod',
        'assignment_method' => 'setAssignmentMethod',
        'assignment_srcaddr_mask' => 'setAssignmentSrcaddrMask',
        'assignment_dstaddr_mask' => 'setAssignmentDstaddrMask'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'service_id' => 'getServiceId',
        'router_id' => 'getRouterId',
        'cache_id' => 'getCacheId',
        'group_address' => 'getGroupAddress',
        'server_list' => 'getServerList',
        'router_list' => 'getRouterList',
        'ports_defined' => 'getPortsDefined',
        'server_type' => 'getServerType',
        'ports' => 'getPorts',
        'authentication' => 'getAuthentication',
        'password' => 'getPassword',
        'forward_method' => 'getForwardMethod',
        'cache_engine_method' => 'getCacheEngineMethod',
        'service_type' => 'getServiceType',
        'primary_hash' => 'getPrimaryHash',
        'priority' => 'getPriority',
        'protocol' => 'getProtocol',
        'assignment_weight' => 'getAssignmentWeight',
        'assignment_bucket_format' => 'getAssignmentBucketFormat',
        'return_method' => 'getReturnMethod',
        'assignment_method' => 'getAssignmentMethod',
        'assignment_srcaddr_mask' => 'getAssignmentSrcaddrMask',
        'assignment_dstaddr_mask' => 'getAssignmentDstaddrMask'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const PORTS_DEFINED_SOURCE = 'source';
    const PORTS_DEFINED_DESTINATION = 'destination';
    const SERVER_TYPE_FORWARD = 'forward';
    const SERVER_TYPE_PROXY = 'proxy';
    const AUTHENTICATION_ENABLE = 'enable';
    const AUTHENTICATION_DISABLE = 'disable';
    const FORWARD_METHOD_GRE = 'GRE';
    const FORWARD_METHOD_L2 = 'L2';
    const FORWARD_METHOD_ANY = 'any';
    const CACHE_ENGINE_METHOD_GRE = 'GRE';
    const CACHE_ENGINE_METHOD_L2 = 'L2';
    const SERVICE_TYPE_AUTO = 'auto';
    const SERVICE_TYPE_STANDARD = 'standard';
    const SERVICE_TYPE_DYNAMIC = 'dynamic';
    const PRIMARY_HASH_SRC_IP = 'src-ip';
    const PRIMARY_HASH_DST_IP = 'dst-ip';
    const PRIMARY_HASH_SRC_PORT = 'src-port';
    const PRIMARY_HASH_DST_PORT = 'dst-port';
    const ASSIGNMENT_BUCKET_FORMAT_WCCP_V2 = 'wccp-v2';
    const ASSIGNMENT_BUCKET_FORMAT_CISCO_IMPLEMENTATION = 'cisco-implementation';
    const RETURN_METHOD_GRE = 'GRE';
    const RETURN_METHOD_L2 = 'L2';
    const RETURN_METHOD_ANY = 'any';
    const ASSIGNMENT_METHOD_HASH = 'HASH';
    const ASSIGNMENT_METHOD_MASK = 'MASK';
    const ASSIGNMENT_METHOD_ANY = 'any';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPortsDefinedAllowableValues()
    {
        return [
            self::PORTS_DEFINED_SOURCE,
            self::PORTS_DEFINED_DESTINATION,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getServerTypeAllowableValues()
    {
        return [
            self::SERVER_TYPE_FORWARD,
            self::SERVER_TYPE_PROXY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthenticationAllowableValues()
    {
        return [
            self::AUTHENTICATION_ENABLE,
            self::AUTHENTICATION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getForwardMethodAllowableValues()
    {
        return [
            self::FORWARD_METHOD_GRE,
            self::FORWARD_METHOD_L2,
            self::FORWARD_METHOD_ANY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCacheEngineMethodAllowableValues()
    {
        return [
            self::CACHE_ENGINE_METHOD_GRE,
            self::CACHE_ENGINE_METHOD_L2,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getServiceTypeAllowableValues()
    {
        return [
            self::SERVICE_TYPE_AUTO,
            self::SERVICE_TYPE_STANDARD,
            self::SERVICE_TYPE_DYNAMIC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPrimaryHashAllowableValues()
    {
        return [
            self::PRIMARY_HASH_SRC_IP,
            self::PRIMARY_HASH_DST_IP,
            self::PRIMARY_HASH_SRC_PORT,
            self::PRIMARY_HASH_DST_PORT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAssignmentBucketFormatAllowableValues()
    {
        return [
            self::ASSIGNMENT_BUCKET_FORMAT_WCCP_V2,
            self::ASSIGNMENT_BUCKET_FORMAT_CISCO_IMPLEMENTATION,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getReturnMethodAllowableValues()
    {
        return [
            self::RETURN_METHOD_GRE,
            self::RETURN_METHOD_L2,
            self::RETURN_METHOD_ANY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAssignmentMethodAllowableValues()
    {
        return [
            self::ASSIGNMENT_METHOD_HASH,
            self::ASSIGNMENT_METHOD_MASK,
            self::ASSIGNMENT_METHOD_ANY,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['service_id'] = $data['service_id'] ?? null;
        $this->container['router_id'] = $data['router_id'] ?? null;
        $this->container['cache_id'] = $data['cache_id'] ?? null;
        $this->container['group_address'] = $data['group_address'] ?? null;
        $this->container['server_list'] = $data['server_list'] ?? null;
        $this->container['router_list'] = $data['router_list'] ?? null;
        $this->container['ports_defined'] = $data['ports_defined'] ?? null;
        $this->container['server_type'] = $data['server_type'] ?? null;
        $this->container['ports'] = $data['ports'] ?? null;
        $this->container['authentication'] = $data['authentication'] ?? null;
        $this->container['password'] = $data['password'] ?? null;
        $this->container['forward_method'] = $data['forward_method'] ?? null;
        $this->container['cache_engine_method'] = $data['cache_engine_method'] ?? null;
        $this->container['service_type'] = $data['service_type'] ?? null;
        $this->container['primary_hash'] = $data['primary_hash'] ?? null;
        $this->container['priority'] = $data['priority'] ?? null;
        $this->container['protocol'] = $data['protocol'] ?? null;
        $this->container['assignment_weight'] = $data['assignment_weight'] ?? null;
        $this->container['assignment_bucket_format'] = $data['assignment_bucket_format'] ?? null;
        $this->container['return_method'] = $data['return_method'] ?? null;
        $this->container['assignment_method'] = $data['assignment_method'] ?? null;
        $this->container['assignment_srcaddr_mask'] = $data['assignment_srcaddr_mask'] ?? null;
        $this->container['assignment_dstaddr_mask'] = $data['assignment_dstaddr_mask'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['service_id']) && (mb_strlen($this->container['service_id']) > 3)) {
            $invalidProperties[] = "invalid value for 'service_id', the character length must be smaller than or equal to 3.";
        }

        $allowedValues = $this->getPortsDefinedAllowableValues();
        if (!is_null($this->container['ports_defined']) && !in_array($this->container['ports_defined'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ports_defined', must be one of '%s'",
                $this->container['ports_defined'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getServerTypeAllowableValues();
        if (!is_null($this->container['server_type']) && !in_array($this->container['server_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'server_type', must be one of '%s'",
                $this->container['server_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthenticationAllowableValues();
        if (!is_null($this->container['authentication']) && !in_array($this->container['authentication'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'authentication', must be one of '%s'",
                $this->container['authentication'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getForwardMethodAllowableValues();
        if (!is_null($this->container['forward_method']) && !in_array($this->container['forward_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'forward_method', must be one of '%s'",
                $this->container['forward_method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCacheEngineMethodAllowableValues();
        if (!is_null($this->container['cache_engine_method']) && !in_array($this->container['cache_engine_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'cache_engine_method', must be one of '%s'",
                $this->container['cache_engine_method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getServiceTypeAllowableValues();
        if (!is_null($this->container['service_type']) && !in_array($this->container['service_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'service_type', must be one of '%s'",
                $this->container['service_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPrimaryHashAllowableValues();
        if (!is_null($this->container['primary_hash']) && !in_array($this->container['primary_hash'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'primary_hash', must be one of '%s'",
                $this->container['primary_hash'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['priority']) && ($this->container['priority'] > 255)) {
            $invalidProperties[] = "invalid value for 'priority', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['priority']) && ($this->container['priority'] < 0)) {
            $invalidProperties[] = "invalid value for 'priority', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['protocol']) && ($this->container['protocol'] > 255)) {
            $invalidProperties[] = "invalid value for 'protocol', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['protocol']) && ($this->container['protocol'] < 0)) {
            $invalidProperties[] = "invalid value for 'protocol', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['assignment_weight']) && ($this->container['assignment_weight'] > 255)) {
            $invalidProperties[] = "invalid value for 'assignment_weight', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['assignment_weight']) && ($this->container['assignment_weight'] < 0)) {
            $invalidProperties[] = "invalid value for 'assignment_weight', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getAssignmentBucketFormatAllowableValues();
        if (!is_null($this->container['assignment_bucket_format']) && !in_array($this->container['assignment_bucket_format'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'assignment_bucket_format', must be one of '%s'",
                $this->container['assignment_bucket_format'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getReturnMethodAllowableValues();
        if (!is_null($this->container['return_method']) && !in_array($this->container['return_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'return_method', must be one of '%s'",
                $this->container['return_method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAssignmentMethodAllowableValues();
        if (!is_null($this->container['assignment_method']) && !in_array($this->container['assignment_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'assignment_method', must be one of '%s'",
                $this->container['assignment_method'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets service_id
     *
     * @return string|null
     */
    public function getServiceId()
    {
        return $this->container['service_id'];
    }

    /**
     * Sets service_id
     *
     * @param string|null $service_id Service ID.
     *
     * @return self
     */
    public function setServiceId($service_id)
    {
        if (!is_null($service_id) && (mb_strlen($service_id) > 3)) {
            throw new \InvalidArgumentException('invalid length for $service_id when calling InlineObject412., must be smaller than or equal to 3.');
        }

        $this->container['service_id'] = $service_id;

        return $this;
    }

    /**
     * Gets router_id
     *
     * @return string|null
     */
    public function getRouterId()
    {
        return $this->container['router_id'];
    }

    /**
     * Sets router_id
     *
     * @param string|null $router_id IP address known to all cache engines. If all cache engines connect to the same FortiGate interface, use the default 0.0.0.0.
     *
     * @return self
     */
    public function setRouterId($router_id)
    {
        $this->container['router_id'] = $router_id;

        return $this;
    }

    /**
     * Gets cache_id
     *
     * @return string|null
     */
    public function getCacheId()
    {
        return $this->container['cache_id'];
    }

    /**
     * Sets cache_id
     *
     * @param string|null $cache_id IP address known to all routers. If the addresses are the same, use the default 0.0.0.0.
     *
     * @return self
     */
    public function setCacheId($cache_id)
    {
        $this->container['cache_id'] = $cache_id;

        return $this;
    }

    /**
     * Gets group_address
     *
     * @return string|null
     */
    public function getGroupAddress()
    {
        return $this->container['group_address'];
    }

    /**
     * Sets group_address
     *
     * @param string|null $group_address IP multicast address used by the cache routers. For the FortiGate to ignore multicast WCCP traffic, use the default 0.0.0.0.
     *
     * @return self
     */
    public function setGroupAddress($group_address)
    {
        $this->container['group_address'] = $group_address;

        return $this;
    }

    /**
     * Gets server_list
     *
     * @return string|null
     */
    public function getServerList()
    {
        return $this->container['server_list'];
    }

    /**
     * Sets server_list
     *
     * @param string|null $server_list IP addresses and netmasks for up to four cache servers.
     *
     * @return self
     */
    public function setServerList($server_list)
    {
        $this->container['server_list'] = $server_list;

        return $this;
    }

    /**
     * Gets router_list
     *
     * @return string|null
     */
    public function getRouterList()
    {
        return $this->container['router_list'];
    }

    /**
     * Sets router_list
     *
     * @param string|null $router_list IP addresses of one or more WCCP routers.
     *
     * @return self
     */
    public function setRouterList($router_list)
    {
        $this->container['router_list'] = $router_list;

        return $this;
    }

    /**
     * Gets ports_defined
     *
     * @return string|null
     */
    public function getPortsDefined()
    {
        return $this->container['ports_defined'];
    }

    /**
     * Sets ports_defined
     *
     * @param string|null $ports_defined Match method.    source:Source port match.    destination:Destination port match.
     *
     * @return self
     */
    public function setPortsDefined($ports_defined)
    {
        $allowedValues = $this->getPortsDefinedAllowableValues();
        if (!is_null($ports_defined) && !in_array($ports_defined, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ports_defined', must be one of '%s'",
                    $ports_defined,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ports_defined'] = $ports_defined;

        return $this;
    }

    /**
     * Gets server_type
     *
     * @return string|null
     */
    public function getServerType()
    {
        return $this->container['server_type'];
    }

    /**
     * Sets server_type
     *
     * @param string|null $server_type Cache server type.    forward:Forward server.    proxy:Proxy server.
     *
     * @return self
     */
    public function setServerType($server_type)
    {
        $allowedValues = $this->getServerTypeAllowableValues();
        if (!is_null($server_type) && !in_array($server_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'server_type', must be one of '%s'",
                    $server_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['server_type'] = $server_type;

        return $this;
    }

    /**
     * Gets ports
     *
     * @return string|null
     */
    public function getPorts()
    {
        return $this->container['ports'];
    }

    /**
     * Sets ports
     *
     * @param string|null $ports Service ports.
     *
     * @return self
     */
    public function setPorts($ports)
    {
        $this->container['ports'] = $ports;

        return $this;
    }

    /**
     * Gets authentication
     *
     * @return string|null
     */
    public function getAuthentication()
    {
        return $this->container['authentication'];
    }

    /**
     * Sets authentication
     *
     * @param string|null $authentication Enable/disable MD5 authentication.    enable:Enable MD5 authentication.    disable:Disable MD5 authentication.
     *
     * @return self
     */
    public function setAuthentication($authentication)
    {
        $allowedValues = $this->getAuthenticationAllowableValues();
        if (!is_null($authentication) && !in_array($authentication, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'authentication', must be one of '%s'",
                    $authentication,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['authentication'] = $authentication;

        return $this;
    }

    /**
     * Gets password
     *
     * @return string|null
     */
    public function getPassword()
    {
        return $this->container['password'];
    }

    /**
     * Sets password
     *
     * @param string|null $password Password for MD5 authentication.
     *
     * @return self
     */
    public function setPassword($password)
    {
        $this->container['password'] = $password;

        return $this;
    }

    /**
     * Gets forward_method
     *
     * @return string|null
     */
    public function getForwardMethod()
    {
        return $this->container['forward_method'];
    }

    /**
     * Sets forward_method
     *
     * @param string|null $forward_method Method used to forward traffic to the cache servers.    GRE:GRE encapsulation.    L2:L2 rewrite.    any:GRE or L2.
     *
     * @return self
     */
    public function setForwardMethod($forward_method)
    {
        $allowedValues = $this->getForwardMethodAllowableValues();
        if (!is_null($forward_method) && !in_array($forward_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'forward_method', must be one of '%s'",
                    $forward_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['forward_method'] = $forward_method;

        return $this;
    }

    /**
     * Gets cache_engine_method
     *
     * @return string|null
     */
    public function getCacheEngineMethod()
    {
        return $this->container['cache_engine_method'];
    }

    /**
     * Sets cache_engine_method
     *
     * @param string|null $cache_engine_method Method used to forward traffic to the routers or to return to the cache engine.    GRE:GRE encapsulation.    L2:L2 rewrite.
     *
     * @return self
     */
    public function setCacheEngineMethod($cache_engine_method)
    {
        $allowedValues = $this->getCacheEngineMethodAllowableValues();
        if (!is_null($cache_engine_method) && !in_array($cache_engine_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'cache_engine_method', must be one of '%s'",
                    $cache_engine_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cache_engine_method'] = $cache_engine_method;

        return $this;
    }

    /**
     * Gets service_type
     *
     * @return string|null
     */
    public function getServiceType()
    {
        return $this->container['service_type'];
    }

    /**
     * Sets service_type
     *
     * @param string|null $service_type WCCP service type used by the cache server for logical interception and redirection of traffic.    auto:auto    standard:Standard service.    dynamic:Dynamic service.
     *
     * @return self
     */
    public function setServiceType($service_type)
    {
        $allowedValues = $this->getServiceTypeAllowableValues();
        if (!is_null($service_type) && !in_array($service_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'service_type', must be one of '%s'",
                    $service_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['service_type'] = $service_type;

        return $this;
    }

    /**
     * Gets primary_hash
     *
     * @return string|null
     */
    public function getPrimaryHash()
    {
        return $this->container['primary_hash'];
    }

    /**
     * Sets primary_hash
     *
     * @param string|null $primary_hash Hash method.    src-ip:Source IP hash.    dst-ip:Destination IP hash.    src-port:Source port hash.    dst-port:Destination port hash.
     *
     * @return self
     */
    public function setPrimaryHash($primary_hash)
    {
        $allowedValues = $this->getPrimaryHashAllowableValues();
        if (!is_null($primary_hash) && !in_array($primary_hash, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'primary_hash', must be one of '%s'",
                    $primary_hash,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['primary_hash'] = $primary_hash;

        return $this;
    }

    /**
     * Gets priority
     *
     * @return int|null
     */
    public function getPriority()
    {
        return $this->container['priority'];
    }

    /**
     * Sets priority
     *
     * @param int|null $priority Service priority.
     *
     * @return self
     */
    public function setPriority($priority)
    {

        if (!is_null($priority) && ($priority > 255)) {
            throw new \InvalidArgumentException('invalid value for $priority when calling InlineObject412., must be smaller than or equal to 255.');
        }
        if (!is_null($priority) && ($priority < 0)) {
            throw new \InvalidArgumentException('invalid value for $priority when calling InlineObject412., must be bigger than or equal to 0.');
        }

        $this->container['priority'] = $priority;

        return $this;
    }

    /**
     * Gets protocol
     *
     * @return int|null
     */
    public function getProtocol()
    {
        return $this->container['protocol'];
    }

    /**
     * Sets protocol
     *
     * @param int|null $protocol Service protocol.
     *
     * @return self
     */
    public function setProtocol($protocol)
    {

        if (!is_null($protocol) && ($protocol > 255)) {
            throw new \InvalidArgumentException('invalid value for $protocol when calling InlineObject412., must be smaller than or equal to 255.');
        }
        if (!is_null($protocol) && ($protocol < 0)) {
            throw new \InvalidArgumentException('invalid value for $protocol when calling InlineObject412., must be bigger than or equal to 0.');
        }

        $this->container['protocol'] = $protocol;

        return $this;
    }

    /**
     * Gets assignment_weight
     *
     * @return int|null
     */
    public function getAssignmentWeight()
    {
        return $this->container['assignment_weight'];
    }

    /**
     * Sets assignment_weight
     *
     * @param int|null $assignment_weight Assignment of hash weight/ratio for the WCCP cache engine.
     *
     * @return self
     */
    public function setAssignmentWeight($assignment_weight)
    {

        if (!is_null($assignment_weight) && ($assignment_weight > 255)) {
            throw new \InvalidArgumentException('invalid value for $assignment_weight when calling InlineObject412., must be smaller than or equal to 255.');
        }
        if (!is_null($assignment_weight) && ($assignment_weight < 0)) {
            throw new \InvalidArgumentException('invalid value for $assignment_weight when calling InlineObject412., must be bigger than or equal to 0.');
        }

        $this->container['assignment_weight'] = $assignment_weight;

        return $this;
    }

    /**
     * Gets assignment_bucket_format
     *
     * @return string|null
     */
    public function getAssignmentBucketFormat()
    {
        return $this->container['assignment_bucket_format'];
    }

    /**
     * Sets assignment_bucket_format
     *
     * @param string|null $assignment_bucket_format Assignment bucket format for the WCCP cache engine.    wccp-v2:WCCP-v2 bucket format.    cisco-implementation:Cisco bucket format.
     *
     * @return self
     */
    public function setAssignmentBucketFormat($assignment_bucket_format)
    {
        $allowedValues = $this->getAssignmentBucketFormatAllowableValues();
        if (!is_null($assignment_bucket_format) && !in_array($assignment_bucket_format, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'assignment_bucket_format', must be one of '%s'",
                    $assignment_bucket_format,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['assignment_bucket_format'] = $assignment_bucket_format;

        return $this;
    }

    /**
     * Gets return_method
     *
     * @return string|null
     */
    public function getReturnMethod()
    {
        return $this->container['return_method'];
    }

    /**
     * Sets return_method
     *
     * @param string|null $return_method Method used to decline a redirected packet and return it to the FortiGate.    GRE:GRE encapsulation.    L2:L2 rewrite.    any:GRE or L2.
     *
     * @return self
     */
    public function setReturnMethod($return_method)
    {
        $allowedValues = $this->getReturnMethodAllowableValues();
        if (!is_null($return_method) && !in_array($return_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'return_method', must be one of '%s'",
                    $return_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['return_method'] = $return_method;

        return $this;
    }

    /**
     * Gets assignment_method
     *
     * @return string|null
     */
    public function getAssignmentMethod()
    {
        return $this->container['assignment_method'];
    }

    /**
     * Sets assignment_method
     *
     * @param string|null $assignment_method Hash key assignment preference.    HASH:HASH assignment method.    MASK:MASK assignment method.    any:HASH or MASK.
     *
     * @return self
     */
    public function setAssignmentMethod($assignment_method)
    {
        $allowedValues = $this->getAssignmentMethodAllowableValues();
        if (!is_null($assignment_method) && !in_array($assignment_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'assignment_method', must be one of '%s'",
                    $assignment_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['assignment_method'] = $assignment_method;

        return $this;
    }

    /**
     * Gets assignment_srcaddr_mask
     *
     * @return string|null
     */
    public function getAssignmentSrcaddrMask()
    {
        return $this->container['assignment_srcaddr_mask'];
    }

    /**
     * Sets assignment_srcaddr_mask
     *
     * @param string|null $assignment_srcaddr_mask Assignment source address mask.
     *
     * @return self
     */
    public function setAssignmentSrcaddrMask($assignment_srcaddr_mask)
    {
        $this->container['assignment_srcaddr_mask'] = $assignment_srcaddr_mask;

        return $this;
    }

    /**
     * Gets assignment_dstaddr_mask
     *
     * @return string|null
     */
    public function getAssignmentDstaddrMask()
    {
        return $this->container['assignment_dstaddr_mask'];
    }

    /**
     * Sets assignment_dstaddr_mask
     *
     * @param string|null $assignment_dstaddr_mask Assignment destination address mask.
     *
     * @return self
     */
    public function setAssignmentDstaddrMask($assignment_dstaddr_mask)
    {
        $this->container['assignment_dstaddr_mask'] = $assignment_dstaddr_mask;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


