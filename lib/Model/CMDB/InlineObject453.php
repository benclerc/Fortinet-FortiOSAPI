<?php
/**
 * InlineObject453
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * InlineObject453 Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class InlineObject453 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'inline_object_453';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'auth_type' => 'string',
        'auth_cert' => 'string',
        'auth_ca_cert' => 'string',
        'auth_secure_http' => 'string',
        'auth_http_basic' => 'string',
        'auth_ssl_allow_renegotiation' => 'string',
        'auth_src_mac' => 'string',
        'auth_on_demand' => 'string',
        'auth_timeout' => 'int',
        'auth_timeout_type' => 'string',
        'auth_portal_timeout' => 'int',
        'radius_ses_timeout_act' => 'string',
        'auth_blackout_time' => 'int',
        'auth_invalid_max' => 'int',
        'auth_lockout_threshold' => 'int',
        'auth_lockout_duration' => 'int',
        'per_policy_disclaimer' => 'string',
        'auth_ports' => '\Fortigate\FortiOS\Model\CMDB\UserSettingAuthPorts[]',
        'auth_ssl_min_proto_version' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'auth_type' => null,
        'auth_cert' => null,
        'auth_ca_cert' => null,
        'auth_secure_http' => null,
        'auth_http_basic' => null,
        'auth_ssl_allow_renegotiation' => null,
        'auth_src_mac' => null,
        'auth_on_demand' => null,
        'auth_timeout' => null,
        'auth_timeout_type' => null,
        'auth_portal_timeout' => null,
        'radius_ses_timeout_act' => null,
        'auth_blackout_time' => null,
        'auth_invalid_max' => null,
        'auth_lockout_threshold' => null,
        'auth_lockout_duration' => null,
        'per_policy_disclaimer' => null,
        'auth_ports' => null,
        'auth_ssl_min_proto_version' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'auth_type' => 'auth-type',
        'auth_cert' => 'auth-cert',
        'auth_ca_cert' => 'auth-ca-cert',
        'auth_secure_http' => 'auth-secure-http',
        'auth_http_basic' => 'auth-http-basic',
        'auth_ssl_allow_renegotiation' => 'auth-ssl-allow-renegotiation',
        'auth_src_mac' => 'auth-src-mac',
        'auth_on_demand' => 'auth-on-demand',
        'auth_timeout' => 'auth-timeout',
        'auth_timeout_type' => 'auth-timeout-type',
        'auth_portal_timeout' => 'auth-portal-timeout',
        'radius_ses_timeout_act' => 'radius-ses-timeout-act',
        'auth_blackout_time' => 'auth-blackout-time',
        'auth_invalid_max' => 'auth-invalid-max',
        'auth_lockout_threshold' => 'auth-lockout-threshold',
        'auth_lockout_duration' => 'auth-lockout-duration',
        'per_policy_disclaimer' => 'per-policy-disclaimer',
        'auth_ports' => 'auth-ports',
        'auth_ssl_min_proto_version' => 'auth-ssl-min-proto-version'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'auth_type' => 'setAuthType',
        'auth_cert' => 'setAuthCert',
        'auth_ca_cert' => 'setAuthCaCert',
        'auth_secure_http' => 'setAuthSecureHttp',
        'auth_http_basic' => 'setAuthHttpBasic',
        'auth_ssl_allow_renegotiation' => 'setAuthSslAllowRenegotiation',
        'auth_src_mac' => 'setAuthSrcMac',
        'auth_on_demand' => 'setAuthOnDemand',
        'auth_timeout' => 'setAuthTimeout',
        'auth_timeout_type' => 'setAuthTimeoutType',
        'auth_portal_timeout' => 'setAuthPortalTimeout',
        'radius_ses_timeout_act' => 'setRadiusSesTimeoutAct',
        'auth_blackout_time' => 'setAuthBlackoutTime',
        'auth_invalid_max' => 'setAuthInvalidMax',
        'auth_lockout_threshold' => 'setAuthLockoutThreshold',
        'auth_lockout_duration' => 'setAuthLockoutDuration',
        'per_policy_disclaimer' => 'setPerPolicyDisclaimer',
        'auth_ports' => 'setAuthPorts',
        'auth_ssl_min_proto_version' => 'setAuthSslMinProtoVersion'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'auth_type' => 'getAuthType',
        'auth_cert' => 'getAuthCert',
        'auth_ca_cert' => 'getAuthCaCert',
        'auth_secure_http' => 'getAuthSecureHttp',
        'auth_http_basic' => 'getAuthHttpBasic',
        'auth_ssl_allow_renegotiation' => 'getAuthSslAllowRenegotiation',
        'auth_src_mac' => 'getAuthSrcMac',
        'auth_on_demand' => 'getAuthOnDemand',
        'auth_timeout' => 'getAuthTimeout',
        'auth_timeout_type' => 'getAuthTimeoutType',
        'auth_portal_timeout' => 'getAuthPortalTimeout',
        'radius_ses_timeout_act' => 'getRadiusSesTimeoutAct',
        'auth_blackout_time' => 'getAuthBlackoutTime',
        'auth_invalid_max' => 'getAuthInvalidMax',
        'auth_lockout_threshold' => 'getAuthLockoutThreshold',
        'auth_lockout_duration' => 'getAuthLockoutDuration',
        'per_policy_disclaimer' => 'getPerPolicyDisclaimer',
        'auth_ports' => 'getAuthPorts',
        'auth_ssl_min_proto_version' => 'getAuthSslMinProtoVersion'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const AUTH_TYPE_HTTP = 'http';
    const AUTH_TYPE_HTTPS = 'https';
    const AUTH_TYPE_FTP = 'ftp';
    const AUTH_TYPE_TELNET = 'telnet';
    const AUTH_SECURE_HTTP_ENABLE = 'enable';
    const AUTH_SECURE_HTTP_DISABLE = 'disable';
    const AUTH_HTTP_BASIC_ENABLE = 'enable';
    const AUTH_HTTP_BASIC_DISABLE = 'disable';
    const AUTH_SSL_ALLOW_RENEGOTIATION_ENABLE = 'enable';
    const AUTH_SSL_ALLOW_RENEGOTIATION_DISABLE = 'disable';
    const AUTH_SRC_MAC_ENABLE = 'enable';
    const AUTH_SRC_MAC_DISABLE = 'disable';
    const AUTH_ON_DEMAND_ALWAYS = 'always';
    const AUTH_ON_DEMAND_IMPLICITLY = 'implicitly';
    const AUTH_TIMEOUT_TYPE_IDLE_TIMEOUT = 'idle-timeout';
    const AUTH_TIMEOUT_TYPE_HARD_TIMEOUT = 'hard-timeout';
    const AUTH_TIMEOUT_TYPE_NEW_SESSION = 'new-session';
    const RADIUS_SES_TIMEOUT_ACT_HARD_TIMEOUT = 'hard-timeout';
    const RADIUS_SES_TIMEOUT_ACT_IGNORE_TIMEOUT = 'ignore-timeout';
    const PER_POLICY_DISCLAIMER_ENABLE = 'enable';
    const PER_POLICY_DISCLAIMER_DISABLE = 'disable';
    const AUTH_SSL_MIN_PROTO_VERSION__DEFAULT = 'default';
    const AUTH_SSL_MIN_PROTO_VERSION_SSLV3 = 'SSLv3';
    const AUTH_SSL_MIN_PROTO_VERSION_TLSV1 = 'TLSv1';
    const AUTH_SSL_MIN_PROTO_VERSION_TLSV1_1 = 'TLSv1-1';
    const AUTH_SSL_MIN_PROTO_VERSION_TLSV1_2 = 'TLSv1-2';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthTypeAllowableValues()
    {
        return [
            self::AUTH_TYPE_HTTP,
            self::AUTH_TYPE_HTTPS,
            self::AUTH_TYPE_FTP,
            self::AUTH_TYPE_TELNET,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSecureHttpAllowableValues()
    {
        return [
            self::AUTH_SECURE_HTTP_ENABLE,
            self::AUTH_SECURE_HTTP_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthHttpBasicAllowableValues()
    {
        return [
            self::AUTH_HTTP_BASIC_ENABLE,
            self::AUTH_HTTP_BASIC_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSslAllowRenegotiationAllowableValues()
    {
        return [
            self::AUTH_SSL_ALLOW_RENEGOTIATION_ENABLE,
            self::AUTH_SSL_ALLOW_RENEGOTIATION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSrcMacAllowableValues()
    {
        return [
            self::AUTH_SRC_MAC_ENABLE,
            self::AUTH_SRC_MAC_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthOnDemandAllowableValues()
    {
        return [
            self::AUTH_ON_DEMAND_ALWAYS,
            self::AUTH_ON_DEMAND_IMPLICITLY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthTimeoutTypeAllowableValues()
    {
        return [
            self::AUTH_TIMEOUT_TYPE_IDLE_TIMEOUT,
            self::AUTH_TIMEOUT_TYPE_HARD_TIMEOUT,
            self::AUTH_TIMEOUT_TYPE_NEW_SESSION,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusSesTimeoutActAllowableValues()
    {
        return [
            self::RADIUS_SES_TIMEOUT_ACT_HARD_TIMEOUT,
            self::RADIUS_SES_TIMEOUT_ACT_IGNORE_TIMEOUT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPerPolicyDisclaimerAllowableValues()
    {
        return [
            self::PER_POLICY_DISCLAIMER_ENABLE,
            self::PER_POLICY_DISCLAIMER_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSslMinProtoVersionAllowableValues()
    {
        return [
            self::AUTH_SSL_MIN_PROTO_VERSION__DEFAULT,
            self::AUTH_SSL_MIN_PROTO_VERSION_SSLV3,
            self::AUTH_SSL_MIN_PROTO_VERSION_TLSV1,
            self::AUTH_SSL_MIN_PROTO_VERSION_TLSV1_1,
            self::AUTH_SSL_MIN_PROTO_VERSION_TLSV1_2,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['auth_type'] = $data['auth_type'] ?? null;
        $this->container['auth_cert'] = $data['auth_cert'] ?? null;
        $this->container['auth_ca_cert'] = $data['auth_ca_cert'] ?? null;
        $this->container['auth_secure_http'] = $data['auth_secure_http'] ?? null;
        $this->container['auth_http_basic'] = $data['auth_http_basic'] ?? null;
        $this->container['auth_ssl_allow_renegotiation'] = $data['auth_ssl_allow_renegotiation'] ?? null;
        $this->container['auth_src_mac'] = $data['auth_src_mac'] ?? null;
        $this->container['auth_on_demand'] = $data['auth_on_demand'] ?? null;
        $this->container['auth_timeout'] = $data['auth_timeout'] ?? null;
        $this->container['auth_timeout_type'] = $data['auth_timeout_type'] ?? null;
        $this->container['auth_portal_timeout'] = $data['auth_portal_timeout'] ?? null;
        $this->container['radius_ses_timeout_act'] = $data['radius_ses_timeout_act'] ?? null;
        $this->container['auth_blackout_time'] = $data['auth_blackout_time'] ?? null;
        $this->container['auth_invalid_max'] = $data['auth_invalid_max'] ?? null;
        $this->container['auth_lockout_threshold'] = $data['auth_lockout_threshold'] ?? null;
        $this->container['auth_lockout_duration'] = $data['auth_lockout_duration'] ?? null;
        $this->container['per_policy_disclaimer'] = $data['per_policy_disclaimer'] ?? null;
        $this->container['auth_ports'] = $data['auth_ports'] ?? null;
        $this->container['auth_ssl_min_proto_version'] = $data['auth_ssl_min_proto_version'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getAuthTypeAllowableValues();
        if (!is_null($this->container['auth_type']) && !in_array($this->container['auth_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_type', must be one of '%s'",
                $this->container['auth_type'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['auth_cert']) && (mb_strlen($this->container['auth_cert']) > 35)) {
            $invalidProperties[] = "invalid value for 'auth_cert', the character length must be smaller than or equal to 35.";
        }

        if (!is_null($this->container['auth_ca_cert']) && (mb_strlen($this->container['auth_ca_cert']) > 35)) {
            $invalidProperties[] = "invalid value for 'auth_ca_cert', the character length must be smaller than or equal to 35.";
        }

        $allowedValues = $this->getAuthSecureHttpAllowableValues();
        if (!is_null($this->container['auth_secure_http']) && !in_array($this->container['auth_secure_http'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_secure_http', must be one of '%s'",
                $this->container['auth_secure_http'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthHttpBasicAllowableValues();
        if (!is_null($this->container['auth_http_basic']) && !in_array($this->container['auth_http_basic'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_http_basic', must be one of '%s'",
                $this->container['auth_http_basic'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthSslAllowRenegotiationAllowableValues();
        if (!is_null($this->container['auth_ssl_allow_renegotiation']) && !in_array($this->container['auth_ssl_allow_renegotiation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_ssl_allow_renegotiation', must be one of '%s'",
                $this->container['auth_ssl_allow_renegotiation'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthSrcMacAllowableValues();
        if (!is_null($this->container['auth_src_mac']) && !in_array($this->container['auth_src_mac'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_src_mac', must be one of '%s'",
                $this->container['auth_src_mac'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAuthOnDemandAllowableValues();
        if (!is_null($this->container['auth_on_demand']) && !in_array($this->container['auth_on_demand'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_on_demand', must be one of '%s'",
                $this->container['auth_on_demand'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['auth_timeout']) && ($this->container['auth_timeout'] > 1440)) {
            $invalidProperties[] = "invalid value for 'auth_timeout', must be smaller than or equal to 1440.";
        }

        if (!is_null($this->container['auth_timeout']) && ($this->container['auth_timeout'] < 1)) {
            $invalidProperties[] = "invalid value for 'auth_timeout', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getAuthTimeoutTypeAllowableValues();
        if (!is_null($this->container['auth_timeout_type']) && !in_array($this->container['auth_timeout_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_timeout_type', must be one of '%s'",
                $this->container['auth_timeout_type'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['auth_portal_timeout']) && ($this->container['auth_portal_timeout'] > 30)) {
            $invalidProperties[] = "invalid value for 'auth_portal_timeout', must be smaller than or equal to 30.";
        }

        if (!is_null($this->container['auth_portal_timeout']) && ($this->container['auth_portal_timeout'] < 1)) {
            $invalidProperties[] = "invalid value for 'auth_portal_timeout', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getRadiusSesTimeoutActAllowableValues();
        if (!is_null($this->container['radius_ses_timeout_act']) && !in_array($this->container['radius_ses_timeout_act'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'radius_ses_timeout_act', must be one of '%s'",
                $this->container['radius_ses_timeout_act'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['auth_blackout_time']) && ($this->container['auth_blackout_time'] > 3600)) {
            $invalidProperties[] = "invalid value for 'auth_blackout_time', must be smaller than or equal to 3600.";
        }

        if (!is_null($this->container['auth_blackout_time']) && ($this->container['auth_blackout_time'] < 0)) {
            $invalidProperties[] = "invalid value for 'auth_blackout_time', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['auth_invalid_max']) && ($this->container['auth_invalid_max'] > 100)) {
            $invalidProperties[] = "invalid value for 'auth_invalid_max', must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['auth_invalid_max']) && ($this->container['auth_invalid_max'] < 1)) {
            $invalidProperties[] = "invalid value for 'auth_invalid_max', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['auth_lockout_threshold']) && ($this->container['auth_lockout_threshold'] > 10)) {
            $invalidProperties[] = "invalid value for 'auth_lockout_threshold', must be smaller than or equal to 10.";
        }

        if (!is_null($this->container['auth_lockout_threshold']) && ($this->container['auth_lockout_threshold'] < 1)) {
            $invalidProperties[] = "invalid value for 'auth_lockout_threshold', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['auth_lockout_duration']) && ($this->container['auth_lockout_duration'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'auth_lockout_duration', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['auth_lockout_duration']) && ($this->container['auth_lockout_duration'] < 0)) {
            $invalidProperties[] = "invalid value for 'auth_lockout_duration', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getPerPolicyDisclaimerAllowableValues();
        if (!is_null($this->container['per_policy_disclaimer']) && !in_array($this->container['per_policy_disclaimer'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'per_policy_disclaimer', must be one of '%s'",
                $this->container['per_policy_disclaimer'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['auth_ports']) && (count($this->container['auth_ports']) > 0)) {
            $invalidProperties[] = "invalid value for 'auth_ports', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getAuthSslMinProtoVersionAllowableValues();
        if (!is_null($this->container['auth_ssl_min_proto_version']) && !in_array($this->container['auth_ssl_min_proto_version'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_ssl_min_proto_version', must be one of '%s'",
                $this->container['auth_ssl_min_proto_version'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets auth_type
     *
     * @return string|null
     */
    public function getAuthType()
    {
        return $this->container['auth_type'];
    }

    /**
     * Sets auth_type
     *
     * @param string|null $auth_type Supported firewall policy authentication protocols/methods.    http:Allow HTTP authentication.    https:Allow HTTPS authentication.    ftp:Allow FTP authentication.    telnet:Allow TELNET authentication.
     *
     * @return self
     */
    public function setAuthType($auth_type)
    {
        $allowedValues = $this->getAuthTypeAllowableValues();
        if (!is_null($auth_type) && !in_array($auth_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_type', must be one of '%s'",
                    $auth_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_type'] = $auth_type;

        return $this;
    }

    /**
     * Gets auth_cert
     *
     * @return string|null
     */
    public function getAuthCert()
    {
        return $this->container['auth_cert'];
    }

    /**
     * Sets auth_cert
     *
     * @param string|null $auth_cert HTTPS server certificate for policy authentication.
     *
     * @return self
     */
    public function setAuthCert($auth_cert)
    {
        if (!is_null($auth_cert) && (mb_strlen($auth_cert) > 35)) {
            throw new \InvalidArgumentException('invalid length for $auth_cert when calling InlineObject453., must be smaller than or equal to 35.');
        }

        $this->container['auth_cert'] = $auth_cert;

        return $this;
    }

    /**
     * Gets auth_ca_cert
     *
     * @return string|null
     */
    public function getAuthCaCert()
    {
        return $this->container['auth_ca_cert'];
    }

    /**
     * Sets auth_ca_cert
     *
     * @param string|null $auth_ca_cert HTTPS CA certificate for policy authentication.
     *
     * @return self
     */
    public function setAuthCaCert($auth_ca_cert)
    {
        if (!is_null($auth_ca_cert) && (mb_strlen($auth_ca_cert) > 35)) {
            throw new \InvalidArgumentException('invalid length for $auth_ca_cert when calling InlineObject453., must be smaller than or equal to 35.');
        }

        $this->container['auth_ca_cert'] = $auth_ca_cert;

        return $this;
    }

    /**
     * Gets auth_secure_http
     *
     * @return string|null
     */
    public function getAuthSecureHttp()
    {
        return $this->container['auth_secure_http'];
    }

    /**
     * Sets auth_secure_http
     *
     * @param string|null $auth_secure_http Enable/disable redirecting HTTP user authentication to more secure HTTPS.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setAuthSecureHttp($auth_secure_http)
    {
        $allowedValues = $this->getAuthSecureHttpAllowableValues();
        if (!is_null($auth_secure_http) && !in_array($auth_secure_http, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_secure_http', must be one of '%s'",
                    $auth_secure_http,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_secure_http'] = $auth_secure_http;

        return $this;
    }

    /**
     * Gets auth_http_basic
     *
     * @return string|null
     */
    public function getAuthHttpBasic()
    {
        return $this->container['auth_http_basic'];
    }

    /**
     * Sets auth_http_basic
     *
     * @param string|null $auth_http_basic Enable/disable use of HTTP basic authentication for identity-based firewall policies.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setAuthHttpBasic($auth_http_basic)
    {
        $allowedValues = $this->getAuthHttpBasicAllowableValues();
        if (!is_null($auth_http_basic) && !in_array($auth_http_basic, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_http_basic', must be one of '%s'",
                    $auth_http_basic,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_http_basic'] = $auth_http_basic;

        return $this;
    }

    /**
     * Gets auth_ssl_allow_renegotiation
     *
     * @return string|null
     */
    public function getAuthSslAllowRenegotiation()
    {
        return $this->container['auth_ssl_allow_renegotiation'];
    }

    /**
     * Sets auth_ssl_allow_renegotiation
     *
     * @param string|null $auth_ssl_allow_renegotiation Allow/forbid SSL re-negotiation for HTTPS authentication.    enable:Allow SSL re-negotiation.    disable:Forbid SSL re-negotiation.
     *
     * @return self
     */
    public function setAuthSslAllowRenegotiation($auth_ssl_allow_renegotiation)
    {
        $allowedValues = $this->getAuthSslAllowRenegotiationAllowableValues();
        if (!is_null($auth_ssl_allow_renegotiation) && !in_array($auth_ssl_allow_renegotiation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_ssl_allow_renegotiation', must be one of '%s'",
                    $auth_ssl_allow_renegotiation,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_ssl_allow_renegotiation'] = $auth_ssl_allow_renegotiation;

        return $this;
    }

    /**
     * Gets auth_src_mac
     *
     * @return string|null
     */
    public function getAuthSrcMac()
    {
        return $this->container['auth_src_mac'];
    }

    /**
     * Sets auth_src_mac
     *
     * @param string|null $auth_src_mac Enable/disable source MAC for user identity.    enable:Enable source MAC for user identity.    disable:Disable source MAC for user identity.
     *
     * @return self
     */
    public function setAuthSrcMac($auth_src_mac)
    {
        $allowedValues = $this->getAuthSrcMacAllowableValues();
        if (!is_null($auth_src_mac) && !in_array($auth_src_mac, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_src_mac', must be one of '%s'",
                    $auth_src_mac,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_src_mac'] = $auth_src_mac;

        return $this;
    }

    /**
     * Gets auth_on_demand
     *
     * @return string|null
     */
    public function getAuthOnDemand()
    {
        return $this->container['auth_on_demand'];
    }

    /**
     * Sets auth_on_demand
     *
     * @param string|null $auth_on_demand Always/implicitly trigger firewall authentication on demand.    always:Always trigger firewall authentication on demand.    implicitly:Implicitly trigger firewall authentication on demand.
     *
     * @return self
     */
    public function setAuthOnDemand($auth_on_demand)
    {
        $allowedValues = $this->getAuthOnDemandAllowableValues();
        if (!is_null($auth_on_demand) && !in_array($auth_on_demand, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_on_demand', must be one of '%s'",
                    $auth_on_demand,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_on_demand'] = $auth_on_demand;

        return $this;
    }

    /**
     * Gets auth_timeout
     *
     * @return int|null
     */
    public function getAuthTimeout()
    {
        return $this->container['auth_timeout'];
    }

    /**
     * Sets auth_timeout
     *
     * @param int|null $auth_timeout Time in minutes before the firewall user authentication timeout requires the user to re-authenticate.
     *
     * @return self
     */
    public function setAuthTimeout($auth_timeout)
    {

        if (!is_null($auth_timeout) && ($auth_timeout > 1440)) {
            throw new \InvalidArgumentException('invalid value for $auth_timeout when calling InlineObject453., must be smaller than or equal to 1440.');
        }
        if (!is_null($auth_timeout) && ($auth_timeout < 1)) {
            throw new \InvalidArgumentException('invalid value for $auth_timeout when calling InlineObject453., must be bigger than or equal to 1.');
        }

        $this->container['auth_timeout'] = $auth_timeout;

        return $this;
    }

    /**
     * Gets auth_timeout_type
     *
     * @return string|null
     */
    public function getAuthTimeoutType()
    {
        return $this->container['auth_timeout_type'];
    }

    /**
     * Sets auth_timeout_type
     *
     * @param string|null $auth_timeout_type Control if authenticated users have to login again after a hard timeout, after an idle timeout, or after a session timeout.    idle-timeout:Idle timeout.    hard-timeout:Hard timeout.    new-session:New session timeout.
     *
     * @return self
     */
    public function setAuthTimeoutType($auth_timeout_type)
    {
        $allowedValues = $this->getAuthTimeoutTypeAllowableValues();
        if (!is_null($auth_timeout_type) && !in_array($auth_timeout_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_timeout_type', must be one of '%s'",
                    $auth_timeout_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_timeout_type'] = $auth_timeout_type;

        return $this;
    }

    /**
     * Gets auth_portal_timeout
     *
     * @return int|null
     */
    public function getAuthPortalTimeout()
    {
        return $this->container['auth_portal_timeout'];
    }

    /**
     * Sets auth_portal_timeout
     *
     * @param int|null $auth_portal_timeout Time in minutes before captive portal user have to re-authenticate (1 - 30 min, default 3 min).
     *
     * @return self
     */
    public function setAuthPortalTimeout($auth_portal_timeout)
    {

        if (!is_null($auth_portal_timeout) && ($auth_portal_timeout > 30)) {
            throw new \InvalidArgumentException('invalid value for $auth_portal_timeout when calling InlineObject453., must be smaller than or equal to 30.');
        }
        if (!is_null($auth_portal_timeout) && ($auth_portal_timeout < 1)) {
            throw new \InvalidArgumentException('invalid value for $auth_portal_timeout when calling InlineObject453., must be bigger than or equal to 1.');
        }

        $this->container['auth_portal_timeout'] = $auth_portal_timeout;

        return $this;
    }

    /**
     * Gets radius_ses_timeout_act
     *
     * @return string|null
     */
    public function getRadiusSesTimeoutAct()
    {
        return $this->container['radius_ses_timeout_act'];
    }

    /**
     * Sets radius_ses_timeout_act
     *
     * @param string|null $radius_ses_timeout_act Set the RADIUS session timeout to a hard timeout or to ignore RADIUS server session timeouts.    hard-timeout:Use session timeout from RADIUS as hard-timeout.    ignore-timeout:Ignore session timeout from RADIUS.
     *
     * @return self
     */
    public function setRadiusSesTimeoutAct($radius_ses_timeout_act)
    {
        $allowedValues = $this->getRadiusSesTimeoutActAllowableValues();
        if (!is_null($radius_ses_timeout_act) && !in_array($radius_ses_timeout_act, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'radius_ses_timeout_act', must be one of '%s'",
                    $radius_ses_timeout_act,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_ses_timeout_act'] = $radius_ses_timeout_act;

        return $this;
    }

    /**
     * Gets auth_blackout_time
     *
     * @return int|null
     */
    public function getAuthBlackoutTime()
    {
        return $this->container['auth_blackout_time'];
    }

    /**
     * Sets auth_blackout_time
     *
     * @param int|null $auth_blackout_time Time in seconds an IP address is denied access after failing to authenticate five times within one minute.
     *
     * @return self
     */
    public function setAuthBlackoutTime($auth_blackout_time)
    {

        if (!is_null($auth_blackout_time) && ($auth_blackout_time > 3600)) {
            throw new \InvalidArgumentException('invalid value for $auth_blackout_time when calling InlineObject453., must be smaller than or equal to 3600.');
        }
        if (!is_null($auth_blackout_time) && ($auth_blackout_time < 0)) {
            throw new \InvalidArgumentException('invalid value for $auth_blackout_time when calling InlineObject453., must be bigger than or equal to 0.');
        }

        $this->container['auth_blackout_time'] = $auth_blackout_time;

        return $this;
    }

    /**
     * Gets auth_invalid_max
     *
     * @return int|null
     */
    public function getAuthInvalidMax()
    {
        return $this->container['auth_invalid_max'];
    }

    /**
     * Sets auth_invalid_max
     *
     * @param int|null $auth_invalid_max Maximum number of failed authentication attempts before the user is blocked.
     *
     * @return self
     */
    public function setAuthInvalidMax($auth_invalid_max)
    {

        if (!is_null($auth_invalid_max) && ($auth_invalid_max > 100)) {
            throw new \InvalidArgumentException('invalid value for $auth_invalid_max when calling InlineObject453., must be smaller than or equal to 100.');
        }
        if (!is_null($auth_invalid_max) && ($auth_invalid_max < 1)) {
            throw new \InvalidArgumentException('invalid value for $auth_invalid_max when calling InlineObject453., must be bigger than or equal to 1.');
        }

        $this->container['auth_invalid_max'] = $auth_invalid_max;

        return $this;
    }

    /**
     * Gets auth_lockout_threshold
     *
     * @return int|null
     */
    public function getAuthLockoutThreshold()
    {
        return $this->container['auth_lockout_threshold'];
    }

    /**
     * Sets auth_lockout_threshold
     *
     * @param int|null $auth_lockout_threshold Maximum number of failed login attempts before login lockout is triggered.
     *
     * @return self
     */
    public function setAuthLockoutThreshold($auth_lockout_threshold)
    {

        if (!is_null($auth_lockout_threshold) && ($auth_lockout_threshold > 10)) {
            throw new \InvalidArgumentException('invalid value for $auth_lockout_threshold when calling InlineObject453., must be smaller than or equal to 10.');
        }
        if (!is_null($auth_lockout_threshold) && ($auth_lockout_threshold < 1)) {
            throw new \InvalidArgumentException('invalid value for $auth_lockout_threshold when calling InlineObject453., must be bigger than or equal to 1.');
        }

        $this->container['auth_lockout_threshold'] = $auth_lockout_threshold;

        return $this;
    }

    /**
     * Gets auth_lockout_duration
     *
     * @return int|null
     */
    public function getAuthLockoutDuration()
    {
        return $this->container['auth_lockout_duration'];
    }

    /**
     * Sets auth_lockout_duration
     *
     * @param int|null $auth_lockout_duration Lockout period in seconds after too many login failures.
     *
     * @return self
     */
    public function setAuthLockoutDuration($auth_lockout_duration)
    {

        if (!is_null($auth_lockout_duration) && ($auth_lockout_duration > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $auth_lockout_duration when calling InlineObject453., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($auth_lockout_duration) && ($auth_lockout_duration < 0)) {
            throw new \InvalidArgumentException('invalid value for $auth_lockout_duration when calling InlineObject453., must be bigger than or equal to 0.');
        }

        $this->container['auth_lockout_duration'] = $auth_lockout_duration;

        return $this;
    }

    /**
     * Gets per_policy_disclaimer
     *
     * @return string|null
     */
    public function getPerPolicyDisclaimer()
    {
        return $this->container['per_policy_disclaimer'];
    }

    /**
     * Sets per_policy_disclaimer
     *
     * @param string|null $per_policy_disclaimer Enable/disable per policy disclaimer.    enable:Enable per policy disclaimer.    disable:Disable per policy disclaimer.
     *
     * @return self
     */
    public function setPerPolicyDisclaimer($per_policy_disclaimer)
    {
        $allowedValues = $this->getPerPolicyDisclaimerAllowableValues();
        if (!is_null($per_policy_disclaimer) && !in_array($per_policy_disclaimer, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'per_policy_disclaimer', must be one of '%s'",
                    $per_policy_disclaimer,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['per_policy_disclaimer'] = $per_policy_disclaimer;

        return $this;
    }

    /**
     * Gets auth_ports
     *
     * @return \Fortigate\FortiOS\Model\CMDB\UserSettingAuthPorts[]|null
     */
    public function getAuthPorts()
    {
        return $this->container['auth_ports'];
    }

    /**
     * Sets auth_ports
     *
     * @param \Fortigate\FortiOS\Model\CMDB\UserSettingAuthPorts[]|null $auth_ports Set up non-standard ports for authentication with HTTP, HTTPS, FTP, and TELNET.
     *
     * @return self
     */
    public function setAuthPorts($auth_ports)
    {

        if (!is_null($auth_ports) && (count($auth_ports) > 0)) {
            throw new \InvalidArgumentException('invalid value for $auth_ports when calling InlineObject453., number of items must be less than or equal to 0.');
        }
        $this->container['auth_ports'] = $auth_ports;

        return $this;
    }

    /**
     * Gets auth_ssl_min_proto_version
     *
     * @return string|null
     */
    public function getAuthSslMinProtoVersion()
    {
        return $this->container['auth_ssl_min_proto_version'];
    }

    /**
     * Sets auth_ssl_min_proto_version
     *
     * @param string|null $auth_ssl_min_proto_version Minimum supported protocol version for SSL/TLS connections (default is to follow system global setting).    default:Follow system global setting.    SSLv3:SSLv3.    TLSv1:TLSv1.    TLSv1-1:TLSv1.1.    TLSv1-2:TLSv1.2.
     *
     * @return self
     */
    public function setAuthSslMinProtoVersion($auth_ssl_min_proto_version)
    {
        $allowedValues = $this->getAuthSslMinProtoVersionAllowableValues();
        if (!is_null($auth_ssl_min_proto_version) && !in_array($auth_ssl_min_proto_version, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_ssl_min_proto_version', must be one of '%s'",
                    $auth_ssl_min_proto_version,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_ssl_min_proto_version'] = $auth_ssl_min_proto_version;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


