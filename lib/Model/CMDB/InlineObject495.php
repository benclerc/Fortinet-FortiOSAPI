<?php
/**
 * InlineObject495
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * InlineObject495 Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class InlineObject495 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'inline_object_495';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'reqclientcert' => 'string',
        'user_peer' => 'string',
        'ssl_max_proto_ver' => 'string',
        'ssl_min_proto_ver' => 'string',
        'banned_cipher' => 'string',
        'ssl_insert_empty_fragment' => 'string',
        'https_redirect' => 'string',
        'x_content_type_options' => 'string',
        'ssl_client_renegotiation' => 'string',
        'force_two_factor_auth' => 'string',
        'unsafe_legacy_renegotiation' => 'string',
        'servercert' => 'string',
        'algorithm' => 'string',
        'idle_timeout' => 'int',
        'auth_timeout' => 'int',
        'login_attempt_limit' => 'int',
        'login_block_time' => 'int',
        'login_timeout' => 'int',
        'dtls_hello_timeout' => 'int',
        'tunnel_ip_pools' => '\Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]',
        'tunnel_ipv6_pools' => '\Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]',
        'dns_suffix' => 'string',
        'dns_server1' => 'string',
        'dns_server2' => 'string',
        'wins_server1' => 'string',
        'wins_server2' => 'string',
        'ipv6_dns_server1' => 'string',
        'ipv6_dns_server2' => 'string',
        'ipv6_wins_server1' => 'string',
        'ipv6_wins_server2' => 'string',
        'url_obscuration' => 'string',
        'http_compression' => 'string',
        'http_only_cookie' => 'string',
        'deflate_compression_level' => 'int',
        'deflate_min_data_size' => 'int',
        'port' => 'int',
        'port_precedence' => 'string',
        'auto_tunnel_static_route' => 'string',
        'header_x_forwarded_for' => 'string',
        'source_interface' => '\Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceInterface[]',
        'source_address' => '\Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]',
        'source_address_negate' => 'string',
        'source_address6' => '\Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceAddress6[]',
        'source_address6_negate' => 'string',
        'default_portal' => 'string',
        'authentication_rule' => '\Fortigate\FortiOS\Model\CMDB\VpnSslSettingsAuthenticationRule[]',
        'dtls_tunnel' => 'string',
        'dtls_max_proto_ver' => 'string',
        'dtls_min_proto_ver' => 'string',
        'check_referer' => 'string',
        'http_request_header_timeout' => 'int',
        'http_request_body_timeout' => 'int',
        'auth_session_check_source_ip' => 'string',
        'tunnel_connect_without_reauth' => 'string',
        'tunnel_user_session_timeout' => 'int',
        'hsts_include_subdomains' => 'string',
        'transform_backward_slashes' => 'string',
        'encode_2f_sequence' => 'string',
        'encrypt_and_store_password' => 'string',
        'client_sigalgs' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'reqclientcert' => null,
        'user_peer' => null,
        'ssl_max_proto_ver' => null,
        'ssl_min_proto_ver' => null,
        'banned_cipher' => null,
        'ssl_insert_empty_fragment' => null,
        'https_redirect' => null,
        'x_content_type_options' => null,
        'ssl_client_renegotiation' => null,
        'force_two_factor_auth' => null,
        'unsafe_legacy_renegotiation' => null,
        'servercert' => null,
        'algorithm' => null,
        'idle_timeout' => null,
        'auth_timeout' => null,
        'login_attempt_limit' => null,
        'login_block_time' => null,
        'login_timeout' => null,
        'dtls_hello_timeout' => null,
        'tunnel_ip_pools' => null,
        'tunnel_ipv6_pools' => null,
        'dns_suffix' => null,
        'dns_server1' => 'ipv4',
        'dns_server2' => 'ipv4',
        'wins_server1' => 'ipv4',
        'wins_server2' => 'ipv4',
        'ipv6_dns_server1' => 'ipv6',
        'ipv6_dns_server2' => 'ipv6',
        'ipv6_wins_server1' => 'ipv6',
        'ipv6_wins_server2' => 'ipv6',
        'url_obscuration' => null,
        'http_compression' => null,
        'http_only_cookie' => null,
        'deflate_compression_level' => null,
        'deflate_min_data_size' => null,
        'port' => null,
        'port_precedence' => null,
        'auto_tunnel_static_route' => null,
        'header_x_forwarded_for' => null,
        'source_interface' => null,
        'source_address' => null,
        'source_address_negate' => null,
        'source_address6' => null,
        'source_address6_negate' => null,
        'default_portal' => null,
        'authentication_rule' => null,
        'dtls_tunnel' => null,
        'dtls_max_proto_ver' => null,
        'dtls_min_proto_ver' => null,
        'check_referer' => null,
        'http_request_header_timeout' => null,
        'http_request_body_timeout' => null,
        'auth_session_check_source_ip' => null,
        'tunnel_connect_without_reauth' => null,
        'tunnel_user_session_timeout' => null,
        'hsts_include_subdomains' => null,
        'transform_backward_slashes' => null,
        'encode_2f_sequence' => null,
        'encrypt_and_store_password' => null,
        'client_sigalgs' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'reqclientcert' => 'reqclientcert',
        'user_peer' => 'user-peer',
        'ssl_max_proto_ver' => 'ssl-max-proto-ver',
        'ssl_min_proto_ver' => 'ssl-min-proto-ver',
        'banned_cipher' => 'banned-cipher',
        'ssl_insert_empty_fragment' => 'ssl-insert-empty-fragment',
        'https_redirect' => 'https-redirect',
        'x_content_type_options' => 'x-content-type-options',
        'ssl_client_renegotiation' => 'ssl-client-renegotiation',
        'force_two_factor_auth' => 'force-two-factor-auth',
        'unsafe_legacy_renegotiation' => 'unsafe-legacy-renegotiation',
        'servercert' => 'servercert',
        'algorithm' => 'algorithm',
        'idle_timeout' => 'idle-timeout',
        'auth_timeout' => 'auth-timeout',
        'login_attempt_limit' => 'login-attempt-limit',
        'login_block_time' => 'login-block-time',
        'login_timeout' => 'login-timeout',
        'dtls_hello_timeout' => 'dtls-hello-timeout',
        'tunnel_ip_pools' => 'tunnel-ip-pools',
        'tunnel_ipv6_pools' => 'tunnel-ipv6-pools',
        'dns_suffix' => 'dns-suffix',
        'dns_server1' => 'dns-server1',
        'dns_server2' => 'dns-server2',
        'wins_server1' => 'wins-server1',
        'wins_server2' => 'wins-server2',
        'ipv6_dns_server1' => 'ipv6-dns-server1',
        'ipv6_dns_server2' => 'ipv6-dns-server2',
        'ipv6_wins_server1' => 'ipv6-wins-server1',
        'ipv6_wins_server2' => 'ipv6-wins-server2',
        'url_obscuration' => 'url-obscuration',
        'http_compression' => 'http-compression',
        'http_only_cookie' => 'http-only-cookie',
        'deflate_compression_level' => 'deflate-compression-level',
        'deflate_min_data_size' => 'deflate-min-data-size',
        'port' => 'port',
        'port_precedence' => 'port-precedence',
        'auto_tunnel_static_route' => 'auto-tunnel-static-route',
        'header_x_forwarded_for' => 'header-x-forwarded-for',
        'source_interface' => 'source-interface',
        'source_address' => 'source-address',
        'source_address_negate' => 'source-address-negate',
        'source_address6' => 'source-address6',
        'source_address6_negate' => 'source-address6-negate',
        'default_portal' => 'default-portal',
        'authentication_rule' => 'authentication-rule',
        'dtls_tunnel' => 'dtls-tunnel',
        'dtls_max_proto_ver' => 'dtls-max-proto-ver',
        'dtls_min_proto_ver' => 'dtls-min-proto-ver',
        'check_referer' => 'check-referer',
        'http_request_header_timeout' => 'http-request-header-timeout',
        'http_request_body_timeout' => 'http-request-body-timeout',
        'auth_session_check_source_ip' => 'auth-session-check-source-ip',
        'tunnel_connect_without_reauth' => 'tunnel-connect-without-reauth',
        'tunnel_user_session_timeout' => 'tunnel-user-session-timeout',
        'hsts_include_subdomains' => 'hsts-include-subdomains',
        'transform_backward_slashes' => 'transform-backward-slashes',
        'encode_2f_sequence' => 'encode-2f-sequence',
        'encrypt_and_store_password' => 'encrypt-and-store-password',
        'client_sigalgs' => 'client-sigalgs'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'reqclientcert' => 'setReqclientcert',
        'user_peer' => 'setUserPeer',
        'ssl_max_proto_ver' => 'setSslMaxProtoVer',
        'ssl_min_proto_ver' => 'setSslMinProtoVer',
        'banned_cipher' => 'setBannedCipher',
        'ssl_insert_empty_fragment' => 'setSslInsertEmptyFragment',
        'https_redirect' => 'setHttpsRedirect',
        'x_content_type_options' => 'setXContentTypeOptions',
        'ssl_client_renegotiation' => 'setSslClientRenegotiation',
        'force_two_factor_auth' => 'setForceTwoFactorAuth',
        'unsafe_legacy_renegotiation' => 'setUnsafeLegacyRenegotiation',
        'servercert' => 'setServercert',
        'algorithm' => 'setAlgorithm',
        'idle_timeout' => 'setIdleTimeout',
        'auth_timeout' => 'setAuthTimeout',
        'login_attempt_limit' => 'setLoginAttemptLimit',
        'login_block_time' => 'setLoginBlockTime',
        'login_timeout' => 'setLoginTimeout',
        'dtls_hello_timeout' => 'setDtlsHelloTimeout',
        'tunnel_ip_pools' => 'setTunnelIpPools',
        'tunnel_ipv6_pools' => 'setTunnelIpv6Pools',
        'dns_suffix' => 'setDnsSuffix',
        'dns_server1' => 'setDnsServer1',
        'dns_server2' => 'setDnsServer2',
        'wins_server1' => 'setWinsServer1',
        'wins_server2' => 'setWinsServer2',
        'ipv6_dns_server1' => 'setIpv6DnsServer1',
        'ipv6_dns_server2' => 'setIpv6DnsServer2',
        'ipv6_wins_server1' => 'setIpv6WinsServer1',
        'ipv6_wins_server2' => 'setIpv6WinsServer2',
        'url_obscuration' => 'setUrlObscuration',
        'http_compression' => 'setHttpCompression',
        'http_only_cookie' => 'setHttpOnlyCookie',
        'deflate_compression_level' => 'setDeflateCompressionLevel',
        'deflate_min_data_size' => 'setDeflateMinDataSize',
        'port' => 'setPort',
        'port_precedence' => 'setPortPrecedence',
        'auto_tunnel_static_route' => 'setAutoTunnelStaticRoute',
        'header_x_forwarded_for' => 'setHeaderXForwardedFor',
        'source_interface' => 'setSourceInterface',
        'source_address' => 'setSourceAddress',
        'source_address_negate' => 'setSourceAddressNegate',
        'source_address6' => 'setSourceAddress6',
        'source_address6_negate' => 'setSourceAddress6Negate',
        'default_portal' => 'setDefaultPortal',
        'authentication_rule' => 'setAuthenticationRule',
        'dtls_tunnel' => 'setDtlsTunnel',
        'dtls_max_proto_ver' => 'setDtlsMaxProtoVer',
        'dtls_min_proto_ver' => 'setDtlsMinProtoVer',
        'check_referer' => 'setCheckReferer',
        'http_request_header_timeout' => 'setHttpRequestHeaderTimeout',
        'http_request_body_timeout' => 'setHttpRequestBodyTimeout',
        'auth_session_check_source_ip' => 'setAuthSessionCheckSourceIp',
        'tunnel_connect_without_reauth' => 'setTunnelConnectWithoutReauth',
        'tunnel_user_session_timeout' => 'setTunnelUserSessionTimeout',
        'hsts_include_subdomains' => 'setHstsIncludeSubdomains',
        'transform_backward_slashes' => 'setTransformBackwardSlashes',
        'encode_2f_sequence' => 'setEncode2fSequence',
        'encrypt_and_store_password' => 'setEncryptAndStorePassword',
        'client_sigalgs' => 'setClientSigalgs'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'reqclientcert' => 'getReqclientcert',
        'user_peer' => 'getUserPeer',
        'ssl_max_proto_ver' => 'getSslMaxProtoVer',
        'ssl_min_proto_ver' => 'getSslMinProtoVer',
        'banned_cipher' => 'getBannedCipher',
        'ssl_insert_empty_fragment' => 'getSslInsertEmptyFragment',
        'https_redirect' => 'getHttpsRedirect',
        'x_content_type_options' => 'getXContentTypeOptions',
        'ssl_client_renegotiation' => 'getSslClientRenegotiation',
        'force_two_factor_auth' => 'getForceTwoFactorAuth',
        'unsafe_legacy_renegotiation' => 'getUnsafeLegacyRenegotiation',
        'servercert' => 'getServercert',
        'algorithm' => 'getAlgorithm',
        'idle_timeout' => 'getIdleTimeout',
        'auth_timeout' => 'getAuthTimeout',
        'login_attempt_limit' => 'getLoginAttemptLimit',
        'login_block_time' => 'getLoginBlockTime',
        'login_timeout' => 'getLoginTimeout',
        'dtls_hello_timeout' => 'getDtlsHelloTimeout',
        'tunnel_ip_pools' => 'getTunnelIpPools',
        'tunnel_ipv6_pools' => 'getTunnelIpv6Pools',
        'dns_suffix' => 'getDnsSuffix',
        'dns_server1' => 'getDnsServer1',
        'dns_server2' => 'getDnsServer2',
        'wins_server1' => 'getWinsServer1',
        'wins_server2' => 'getWinsServer2',
        'ipv6_dns_server1' => 'getIpv6DnsServer1',
        'ipv6_dns_server2' => 'getIpv6DnsServer2',
        'ipv6_wins_server1' => 'getIpv6WinsServer1',
        'ipv6_wins_server2' => 'getIpv6WinsServer2',
        'url_obscuration' => 'getUrlObscuration',
        'http_compression' => 'getHttpCompression',
        'http_only_cookie' => 'getHttpOnlyCookie',
        'deflate_compression_level' => 'getDeflateCompressionLevel',
        'deflate_min_data_size' => 'getDeflateMinDataSize',
        'port' => 'getPort',
        'port_precedence' => 'getPortPrecedence',
        'auto_tunnel_static_route' => 'getAutoTunnelStaticRoute',
        'header_x_forwarded_for' => 'getHeaderXForwardedFor',
        'source_interface' => 'getSourceInterface',
        'source_address' => 'getSourceAddress',
        'source_address_negate' => 'getSourceAddressNegate',
        'source_address6' => 'getSourceAddress6',
        'source_address6_negate' => 'getSourceAddress6Negate',
        'default_portal' => 'getDefaultPortal',
        'authentication_rule' => 'getAuthenticationRule',
        'dtls_tunnel' => 'getDtlsTunnel',
        'dtls_max_proto_ver' => 'getDtlsMaxProtoVer',
        'dtls_min_proto_ver' => 'getDtlsMinProtoVer',
        'check_referer' => 'getCheckReferer',
        'http_request_header_timeout' => 'getHttpRequestHeaderTimeout',
        'http_request_body_timeout' => 'getHttpRequestBodyTimeout',
        'auth_session_check_source_ip' => 'getAuthSessionCheckSourceIp',
        'tunnel_connect_without_reauth' => 'getTunnelConnectWithoutReauth',
        'tunnel_user_session_timeout' => 'getTunnelUserSessionTimeout',
        'hsts_include_subdomains' => 'getHstsIncludeSubdomains',
        'transform_backward_slashes' => 'getTransformBackwardSlashes',
        'encode_2f_sequence' => 'getEncode2fSequence',
        'encrypt_and_store_password' => 'getEncryptAndStorePassword',
        'client_sigalgs' => 'getClientSigalgs'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const REQCLIENTCERT_ENABLE = 'enable';
    const REQCLIENTCERT_DISABLE = 'disable';
    const SSL_MAX_PROTO_VER__0 = 'tls1-0';
    const SSL_MAX_PROTO_VER__1 = 'tls1-1';
    const SSL_MAX_PROTO_VER__2 = 'tls1-2';
    const SSL_MAX_PROTO_VER__3 = 'tls1-3';
    const SSL_MIN_PROTO_VER__0 = 'tls1-0';
    const SSL_MIN_PROTO_VER__1 = 'tls1-1';
    const SSL_MIN_PROTO_VER__2 = 'tls1-2';
    const SSL_MIN_PROTO_VER__3 = 'tls1-3';
    const BANNED_CIPHER_RSA = 'RSA';
    const BANNED_CIPHER_DHE = 'DHE';
    const BANNED_CIPHER_ECDHE = 'ECDHE';
    const BANNED_CIPHER_DSS = 'DSS';
    const BANNED_CIPHER_ECDSA = 'ECDSA';
    const BANNED_CIPHER_AES = 'AES';
    const BANNED_CIPHER_AESGCM = 'AESGCM';
    const BANNED_CIPHER_CAMELLIA = 'CAMELLIA';
    const BANNED_CIPHER__3_DES = '3DES';
    const BANNED_CIPHER_SHA1 = 'SHA1';
    const BANNED_CIPHER_SHA256 = 'SHA256';
    const BANNED_CIPHER_SHA384 = 'SHA384';
    const BANNED_CIPHER__STATIC = 'STATIC';
    const SSL_INSERT_EMPTY_FRAGMENT_ENABLE = 'enable';
    const SSL_INSERT_EMPTY_FRAGMENT_DISABLE = 'disable';
    const HTTPS_REDIRECT_ENABLE = 'enable';
    const HTTPS_REDIRECT_DISABLE = 'disable';
    const X_CONTENT_TYPE_OPTIONS_ENABLE = 'enable';
    const X_CONTENT_TYPE_OPTIONS_DISABLE = 'disable';
    const SSL_CLIENT_RENEGOTIATION_DISABLE = 'disable';
    const SSL_CLIENT_RENEGOTIATION_ENABLE = 'enable';
    const FORCE_TWO_FACTOR_AUTH_ENABLE = 'enable';
    const FORCE_TWO_FACTOR_AUTH_DISABLE = 'disable';
    const UNSAFE_LEGACY_RENEGOTIATION_ENABLE = 'enable';
    const UNSAFE_LEGACY_RENEGOTIATION_DISABLE = 'disable';
    const ALGORITHM_HIGH = 'high';
    const ALGORITHM_MEDIUM = 'medium';
    const ALGORITHM__DEFAULT = 'default';
    const ALGORITHM_LOW = 'low';
    const URL_OBSCURATION_ENABLE = 'enable';
    const URL_OBSCURATION_DISABLE = 'disable';
    const HTTP_COMPRESSION_ENABLE = 'enable';
    const HTTP_COMPRESSION_DISABLE = 'disable';
    const HTTP_ONLY_COOKIE_ENABLE = 'enable';
    const HTTP_ONLY_COOKIE_DISABLE = 'disable';
    const PORT_PRECEDENCE_ENABLE = 'enable';
    const PORT_PRECEDENCE_DISABLE = 'disable';
    const AUTO_TUNNEL_STATIC_ROUTE_ENABLE = 'enable';
    const AUTO_TUNNEL_STATIC_ROUTE_DISABLE = 'disable';
    const HEADER_X_FORWARDED_FOR_PASS = 'pass';
    const HEADER_X_FORWARDED_FOR_ADD = 'add';
    const HEADER_X_FORWARDED_FOR_REMOVE = 'remove';
    const SOURCE_ADDRESS_NEGATE_ENABLE = 'enable';
    const SOURCE_ADDRESS_NEGATE_DISABLE = 'disable';
    const SOURCE_ADDRESS6_NEGATE_ENABLE = 'enable';
    const SOURCE_ADDRESS6_NEGATE_DISABLE = 'disable';
    const DTLS_TUNNEL_ENABLE = 'enable';
    const DTLS_TUNNEL_DISABLE = 'disable';
    const DTLS_MAX_PROTO_VER__0 = 'dtls1-0';
    const DTLS_MAX_PROTO_VER__2 = 'dtls1-2';
    const DTLS_MIN_PROTO_VER__0 = 'dtls1-0';
    const DTLS_MIN_PROTO_VER__2 = 'dtls1-2';
    const CHECK_REFERER_ENABLE = 'enable';
    const CHECK_REFERER_DISABLE = 'disable';
    const AUTH_SESSION_CHECK_SOURCE_IP_ENABLE = 'enable';
    const AUTH_SESSION_CHECK_SOURCE_IP_DISABLE = 'disable';
    const TUNNEL_CONNECT_WITHOUT_REAUTH_ENABLE = 'enable';
    const TUNNEL_CONNECT_WITHOUT_REAUTH_DISABLE = 'disable';
    const HSTS_INCLUDE_SUBDOMAINS_ENABLE = 'enable';
    const HSTS_INCLUDE_SUBDOMAINS_DISABLE = 'disable';
    const TRANSFORM_BACKWARD_SLASHES_ENABLE = 'enable';
    const TRANSFORM_BACKWARD_SLASHES_DISABLE = 'disable';
    const ENCODE_2F_SEQUENCE_ENABLE = 'enable';
    const ENCODE_2F_SEQUENCE_DISABLE = 'disable';
    const ENCRYPT_AND_STORE_PASSWORD_ENABLE = 'enable';
    const ENCRYPT_AND_STORE_PASSWORD_DISABLE = 'disable';
    const CLIENT_SIGALGS_NO_RSA_PSS = 'no-rsa-pss';
    const CLIENT_SIGALGS_ALL = 'all';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getReqclientcertAllowableValues()
    {
        return [
            self::REQCLIENTCERT_ENABLE,
            self::REQCLIENTCERT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSslMaxProtoVerAllowableValues()
    {
        return [
            self::SSL_MAX_PROTO_VER__0,
            self::SSL_MAX_PROTO_VER__1,
            self::SSL_MAX_PROTO_VER__2,
            self::SSL_MAX_PROTO_VER__3,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSslMinProtoVerAllowableValues()
    {
        return [
            self::SSL_MIN_PROTO_VER__0,
            self::SSL_MIN_PROTO_VER__1,
            self::SSL_MIN_PROTO_VER__2,
            self::SSL_MIN_PROTO_VER__3,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBannedCipherAllowableValues()
    {
        return [
            self::BANNED_CIPHER_RSA,
            self::BANNED_CIPHER_DHE,
            self::BANNED_CIPHER_ECDHE,
            self::BANNED_CIPHER_DSS,
            self::BANNED_CIPHER_ECDSA,
            self::BANNED_CIPHER_AES,
            self::BANNED_CIPHER_AESGCM,
            self::BANNED_CIPHER_CAMELLIA,
            self::BANNED_CIPHER__3_DES,
            self::BANNED_CIPHER_SHA1,
            self::BANNED_CIPHER_SHA256,
            self::BANNED_CIPHER_SHA384,
            self::BANNED_CIPHER__STATIC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSslInsertEmptyFragmentAllowableValues()
    {
        return [
            self::SSL_INSERT_EMPTY_FRAGMENT_ENABLE,
            self::SSL_INSERT_EMPTY_FRAGMENT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHttpsRedirectAllowableValues()
    {
        return [
            self::HTTPS_REDIRECT_ENABLE,
            self::HTTPS_REDIRECT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getXContentTypeOptionsAllowableValues()
    {
        return [
            self::X_CONTENT_TYPE_OPTIONS_ENABLE,
            self::X_CONTENT_TYPE_OPTIONS_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSslClientRenegotiationAllowableValues()
    {
        return [
            self::SSL_CLIENT_RENEGOTIATION_DISABLE,
            self::SSL_CLIENT_RENEGOTIATION_ENABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getForceTwoFactorAuthAllowableValues()
    {
        return [
            self::FORCE_TWO_FACTOR_AUTH_ENABLE,
            self::FORCE_TWO_FACTOR_AUTH_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getUnsafeLegacyRenegotiationAllowableValues()
    {
        return [
            self::UNSAFE_LEGACY_RENEGOTIATION_ENABLE,
            self::UNSAFE_LEGACY_RENEGOTIATION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAlgorithmAllowableValues()
    {
        return [
            self::ALGORITHM_HIGH,
            self::ALGORITHM_MEDIUM,
            self::ALGORITHM__DEFAULT,
            self::ALGORITHM_LOW,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getUrlObscurationAllowableValues()
    {
        return [
            self::URL_OBSCURATION_ENABLE,
            self::URL_OBSCURATION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHttpCompressionAllowableValues()
    {
        return [
            self::HTTP_COMPRESSION_ENABLE,
            self::HTTP_COMPRESSION_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHttpOnlyCookieAllowableValues()
    {
        return [
            self::HTTP_ONLY_COOKIE_ENABLE,
            self::HTTP_ONLY_COOKIE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPortPrecedenceAllowableValues()
    {
        return [
            self::PORT_PRECEDENCE_ENABLE,
            self::PORT_PRECEDENCE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAutoTunnelStaticRouteAllowableValues()
    {
        return [
            self::AUTO_TUNNEL_STATIC_ROUTE_ENABLE,
            self::AUTO_TUNNEL_STATIC_ROUTE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHeaderXForwardedForAllowableValues()
    {
        return [
            self::HEADER_X_FORWARDED_FOR_PASS,
            self::HEADER_X_FORWARDED_FOR_ADD,
            self::HEADER_X_FORWARDED_FOR_REMOVE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSourceAddressNegateAllowableValues()
    {
        return [
            self::SOURCE_ADDRESS_NEGATE_ENABLE,
            self::SOURCE_ADDRESS_NEGATE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSourceAddress6NegateAllowableValues()
    {
        return [
            self::SOURCE_ADDRESS6_NEGATE_ENABLE,
            self::SOURCE_ADDRESS6_NEGATE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDtlsTunnelAllowableValues()
    {
        return [
            self::DTLS_TUNNEL_ENABLE,
            self::DTLS_TUNNEL_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDtlsMaxProtoVerAllowableValues()
    {
        return [
            self::DTLS_MAX_PROTO_VER__0,
            self::DTLS_MAX_PROTO_VER__2,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDtlsMinProtoVerAllowableValues()
    {
        return [
            self::DTLS_MIN_PROTO_VER__0,
            self::DTLS_MIN_PROTO_VER__2,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCheckRefererAllowableValues()
    {
        return [
            self::CHECK_REFERER_ENABLE,
            self::CHECK_REFERER_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSessionCheckSourceIpAllowableValues()
    {
        return [
            self::AUTH_SESSION_CHECK_SOURCE_IP_ENABLE,
            self::AUTH_SESSION_CHECK_SOURCE_IP_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTunnelConnectWithoutReauthAllowableValues()
    {
        return [
            self::TUNNEL_CONNECT_WITHOUT_REAUTH_ENABLE,
            self::TUNNEL_CONNECT_WITHOUT_REAUTH_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHstsIncludeSubdomainsAllowableValues()
    {
        return [
            self::HSTS_INCLUDE_SUBDOMAINS_ENABLE,
            self::HSTS_INCLUDE_SUBDOMAINS_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTransformBackwardSlashesAllowableValues()
    {
        return [
            self::TRANSFORM_BACKWARD_SLASHES_ENABLE,
            self::TRANSFORM_BACKWARD_SLASHES_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEncode2fSequenceAllowableValues()
    {
        return [
            self::ENCODE_2F_SEQUENCE_ENABLE,
            self::ENCODE_2F_SEQUENCE_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEncryptAndStorePasswordAllowableValues()
    {
        return [
            self::ENCRYPT_AND_STORE_PASSWORD_ENABLE,
            self::ENCRYPT_AND_STORE_PASSWORD_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getClientSigalgsAllowableValues()
    {
        return [
            self::CLIENT_SIGALGS_NO_RSA_PSS,
            self::CLIENT_SIGALGS_ALL,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['reqclientcert'] = $data['reqclientcert'] ?? null;
        $this->container['user_peer'] = $data['user_peer'] ?? null;
        $this->container['ssl_max_proto_ver'] = $data['ssl_max_proto_ver'] ?? null;
        $this->container['ssl_min_proto_ver'] = $data['ssl_min_proto_ver'] ?? null;
        $this->container['banned_cipher'] = $data['banned_cipher'] ?? null;
        $this->container['ssl_insert_empty_fragment'] = $data['ssl_insert_empty_fragment'] ?? null;
        $this->container['https_redirect'] = $data['https_redirect'] ?? null;
        $this->container['x_content_type_options'] = $data['x_content_type_options'] ?? null;
        $this->container['ssl_client_renegotiation'] = $data['ssl_client_renegotiation'] ?? null;
        $this->container['force_two_factor_auth'] = $data['force_two_factor_auth'] ?? null;
        $this->container['unsafe_legacy_renegotiation'] = $data['unsafe_legacy_renegotiation'] ?? null;
        $this->container['servercert'] = $data['servercert'] ?? null;
        $this->container['algorithm'] = $data['algorithm'] ?? null;
        $this->container['idle_timeout'] = $data['idle_timeout'] ?? null;
        $this->container['auth_timeout'] = $data['auth_timeout'] ?? null;
        $this->container['login_attempt_limit'] = $data['login_attempt_limit'] ?? null;
        $this->container['login_block_time'] = $data['login_block_time'] ?? null;
        $this->container['login_timeout'] = $data['login_timeout'] ?? null;
        $this->container['dtls_hello_timeout'] = $data['dtls_hello_timeout'] ?? null;
        $this->container['tunnel_ip_pools'] = $data['tunnel_ip_pools'] ?? null;
        $this->container['tunnel_ipv6_pools'] = $data['tunnel_ipv6_pools'] ?? null;
        $this->container['dns_suffix'] = $data['dns_suffix'] ?? null;
        $this->container['dns_server1'] = $data['dns_server1'] ?? null;
        $this->container['dns_server2'] = $data['dns_server2'] ?? null;
        $this->container['wins_server1'] = $data['wins_server1'] ?? null;
        $this->container['wins_server2'] = $data['wins_server2'] ?? null;
        $this->container['ipv6_dns_server1'] = $data['ipv6_dns_server1'] ?? null;
        $this->container['ipv6_dns_server2'] = $data['ipv6_dns_server2'] ?? null;
        $this->container['ipv6_wins_server1'] = $data['ipv6_wins_server1'] ?? null;
        $this->container['ipv6_wins_server2'] = $data['ipv6_wins_server2'] ?? null;
        $this->container['url_obscuration'] = $data['url_obscuration'] ?? null;
        $this->container['http_compression'] = $data['http_compression'] ?? null;
        $this->container['http_only_cookie'] = $data['http_only_cookie'] ?? null;
        $this->container['deflate_compression_level'] = $data['deflate_compression_level'] ?? null;
        $this->container['deflate_min_data_size'] = $data['deflate_min_data_size'] ?? null;
        $this->container['port'] = $data['port'] ?? null;
        $this->container['port_precedence'] = $data['port_precedence'] ?? null;
        $this->container['auto_tunnel_static_route'] = $data['auto_tunnel_static_route'] ?? null;
        $this->container['header_x_forwarded_for'] = $data['header_x_forwarded_for'] ?? null;
        $this->container['source_interface'] = $data['source_interface'] ?? null;
        $this->container['source_address'] = $data['source_address'] ?? null;
        $this->container['source_address_negate'] = $data['source_address_negate'] ?? null;
        $this->container['source_address6'] = $data['source_address6'] ?? null;
        $this->container['source_address6_negate'] = $data['source_address6_negate'] ?? null;
        $this->container['default_portal'] = $data['default_portal'] ?? null;
        $this->container['authentication_rule'] = $data['authentication_rule'] ?? null;
        $this->container['dtls_tunnel'] = $data['dtls_tunnel'] ?? null;
        $this->container['dtls_max_proto_ver'] = $data['dtls_max_proto_ver'] ?? null;
        $this->container['dtls_min_proto_ver'] = $data['dtls_min_proto_ver'] ?? null;
        $this->container['check_referer'] = $data['check_referer'] ?? null;
        $this->container['http_request_header_timeout'] = $data['http_request_header_timeout'] ?? null;
        $this->container['http_request_body_timeout'] = $data['http_request_body_timeout'] ?? null;
        $this->container['auth_session_check_source_ip'] = $data['auth_session_check_source_ip'] ?? null;
        $this->container['tunnel_connect_without_reauth'] = $data['tunnel_connect_without_reauth'] ?? null;
        $this->container['tunnel_user_session_timeout'] = $data['tunnel_user_session_timeout'] ?? null;
        $this->container['hsts_include_subdomains'] = $data['hsts_include_subdomains'] ?? null;
        $this->container['transform_backward_slashes'] = $data['transform_backward_slashes'] ?? null;
        $this->container['encode_2f_sequence'] = $data['encode_2f_sequence'] ?? null;
        $this->container['encrypt_and_store_password'] = $data['encrypt_and_store_password'] ?? null;
        $this->container['client_sigalgs'] = $data['client_sigalgs'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getReqclientcertAllowableValues();
        if (!is_null($this->container['reqclientcert']) && !in_array($this->container['reqclientcert'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'reqclientcert', must be one of '%s'",
                $this->container['reqclientcert'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['user_peer']) && (mb_strlen($this->container['user_peer']) > 35)) {
            $invalidProperties[] = "invalid value for 'user_peer', the character length must be smaller than or equal to 35.";
        }

        $allowedValues = $this->getSslMaxProtoVerAllowableValues();
        if (!is_null($this->container['ssl_max_proto_ver']) && !in_array($this->container['ssl_max_proto_ver'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ssl_max_proto_ver', must be one of '%s'",
                $this->container['ssl_max_proto_ver'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSslMinProtoVerAllowableValues();
        if (!is_null($this->container['ssl_min_proto_ver']) && !in_array($this->container['ssl_min_proto_ver'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ssl_min_proto_ver', must be one of '%s'",
                $this->container['ssl_min_proto_ver'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getBannedCipherAllowableValues();
        if (!is_null($this->container['banned_cipher']) && !in_array($this->container['banned_cipher'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'banned_cipher', must be one of '%s'",
                $this->container['banned_cipher'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSslInsertEmptyFragmentAllowableValues();
        if (!is_null($this->container['ssl_insert_empty_fragment']) && !in_array($this->container['ssl_insert_empty_fragment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ssl_insert_empty_fragment', must be one of '%s'",
                $this->container['ssl_insert_empty_fragment'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHttpsRedirectAllowableValues();
        if (!is_null($this->container['https_redirect']) && !in_array($this->container['https_redirect'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'https_redirect', must be one of '%s'",
                $this->container['https_redirect'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getXContentTypeOptionsAllowableValues();
        if (!is_null($this->container['x_content_type_options']) && !in_array($this->container['x_content_type_options'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'x_content_type_options', must be one of '%s'",
                $this->container['x_content_type_options'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSslClientRenegotiationAllowableValues();
        if (!is_null($this->container['ssl_client_renegotiation']) && !in_array($this->container['ssl_client_renegotiation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'ssl_client_renegotiation', must be one of '%s'",
                $this->container['ssl_client_renegotiation'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getForceTwoFactorAuthAllowableValues();
        if (!is_null($this->container['force_two_factor_auth']) && !in_array($this->container['force_two_factor_auth'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'force_two_factor_auth', must be one of '%s'",
                $this->container['force_two_factor_auth'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getUnsafeLegacyRenegotiationAllowableValues();
        if (!is_null($this->container['unsafe_legacy_renegotiation']) && !in_array($this->container['unsafe_legacy_renegotiation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'unsafe_legacy_renegotiation', must be one of '%s'",
                $this->container['unsafe_legacy_renegotiation'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['servercert']) && (mb_strlen($this->container['servercert']) > 35)) {
            $invalidProperties[] = "invalid value for 'servercert', the character length must be smaller than or equal to 35.";
        }

        $allowedValues = $this->getAlgorithmAllowableValues();
        if (!is_null($this->container['algorithm']) && !in_array($this->container['algorithm'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'algorithm', must be one of '%s'",
                $this->container['algorithm'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['idle_timeout']) && ($this->container['idle_timeout'] > 259200)) {
            $invalidProperties[] = "invalid value for 'idle_timeout', must be smaller than or equal to 259200.";
        }

        if (!is_null($this->container['idle_timeout']) && ($this->container['idle_timeout'] < 0)) {
            $invalidProperties[] = "invalid value for 'idle_timeout', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['auth_timeout']) && ($this->container['auth_timeout'] > 259200)) {
            $invalidProperties[] = "invalid value for 'auth_timeout', must be smaller than or equal to 259200.";
        }

        if (!is_null($this->container['auth_timeout']) && ($this->container['auth_timeout'] < 0)) {
            $invalidProperties[] = "invalid value for 'auth_timeout', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['login_attempt_limit']) && ($this->container['login_attempt_limit'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'login_attempt_limit', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['login_attempt_limit']) && ($this->container['login_attempt_limit'] < 0)) {
            $invalidProperties[] = "invalid value for 'login_attempt_limit', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['login_block_time']) && ($this->container['login_block_time'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'login_block_time', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['login_block_time']) && ($this->container['login_block_time'] < 0)) {
            $invalidProperties[] = "invalid value for 'login_block_time', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['login_timeout']) && ($this->container['login_timeout'] > 180)) {
            $invalidProperties[] = "invalid value for 'login_timeout', must be smaller than or equal to 180.";
        }

        if (!is_null($this->container['login_timeout']) && ($this->container['login_timeout'] < 10)) {
            $invalidProperties[] = "invalid value for 'login_timeout', must be bigger than or equal to 10.";
        }

        if (!is_null($this->container['dtls_hello_timeout']) && ($this->container['dtls_hello_timeout'] > 60)) {
            $invalidProperties[] = "invalid value for 'dtls_hello_timeout', must be smaller than or equal to 60.";
        }

        if (!is_null($this->container['dtls_hello_timeout']) && ($this->container['dtls_hello_timeout'] < 10)) {
            $invalidProperties[] = "invalid value for 'dtls_hello_timeout', must be bigger than or equal to 10.";
        }

        if (!is_null($this->container['tunnel_ip_pools']) && (count($this->container['tunnel_ip_pools']) > 0)) {
            $invalidProperties[] = "invalid value for 'tunnel_ip_pools', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['tunnel_ipv6_pools']) && (count($this->container['tunnel_ipv6_pools']) > 0)) {
            $invalidProperties[] = "invalid value for 'tunnel_ipv6_pools', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['dns_suffix']) && (mb_strlen($this->container['dns_suffix']) > 253)) {
            $invalidProperties[] = "invalid value for 'dns_suffix', the character length must be smaller than or equal to 253.";
        }

        $allowedValues = $this->getUrlObscurationAllowableValues();
        if (!is_null($this->container['url_obscuration']) && !in_array($this->container['url_obscuration'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'url_obscuration', must be one of '%s'",
                $this->container['url_obscuration'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHttpCompressionAllowableValues();
        if (!is_null($this->container['http_compression']) && !in_array($this->container['http_compression'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'http_compression', must be one of '%s'",
                $this->container['http_compression'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHttpOnlyCookieAllowableValues();
        if (!is_null($this->container['http_only_cookie']) && !in_array($this->container['http_only_cookie'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'http_only_cookie', must be one of '%s'",
                $this->container['http_only_cookie'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['deflate_compression_level']) && ($this->container['deflate_compression_level'] > 9)) {
            $invalidProperties[] = "invalid value for 'deflate_compression_level', must be smaller than or equal to 9.";
        }

        if (!is_null($this->container['deflate_compression_level']) && ($this->container['deflate_compression_level'] < 0)) {
            $invalidProperties[] = "invalid value for 'deflate_compression_level', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['deflate_min_data_size']) && ($this->container['deflate_min_data_size'] > 65535)) {
            $invalidProperties[] = "invalid value for 'deflate_min_data_size', must be smaller than or equal to 65535.";
        }

        if (!is_null($this->container['deflate_min_data_size']) && ($this->container['deflate_min_data_size'] < 200)) {
            $invalidProperties[] = "invalid value for 'deflate_min_data_size', must be bigger than or equal to 200.";
        }

        if (!is_null($this->container['port']) && ($this->container['port'] > 65535)) {
            $invalidProperties[] = "invalid value for 'port', must be smaller than or equal to 65535.";
        }

        if (!is_null($this->container['port']) && ($this->container['port'] < 1)) {
            $invalidProperties[] = "invalid value for 'port', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getPortPrecedenceAllowableValues();
        if (!is_null($this->container['port_precedence']) && !in_array($this->container['port_precedence'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'port_precedence', must be one of '%s'",
                $this->container['port_precedence'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAutoTunnelStaticRouteAllowableValues();
        if (!is_null($this->container['auto_tunnel_static_route']) && !in_array($this->container['auto_tunnel_static_route'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auto_tunnel_static_route', must be one of '%s'",
                $this->container['auto_tunnel_static_route'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getHeaderXForwardedForAllowableValues();
        if (!is_null($this->container['header_x_forwarded_for']) && !in_array($this->container['header_x_forwarded_for'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'header_x_forwarded_for', must be one of '%s'",
                $this->container['header_x_forwarded_for'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['source_interface']) && (count($this->container['source_interface']) > 0)) {
            $invalidProperties[] = "invalid value for 'source_interface', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['source_address']) && (count($this->container['source_address']) > 0)) {
            $invalidProperties[] = "invalid value for 'source_address', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getSourceAddressNegateAllowableValues();
        if (!is_null($this->container['source_address_negate']) && !in_array($this->container['source_address_negate'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'source_address_negate', must be one of '%s'",
                $this->container['source_address_negate'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['source_address6']) && (count($this->container['source_address6']) > 0)) {
            $invalidProperties[] = "invalid value for 'source_address6', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getSourceAddress6NegateAllowableValues();
        if (!is_null($this->container['source_address6_negate']) && !in_array($this->container['source_address6_negate'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'source_address6_negate', must be one of '%s'",
                $this->container['source_address6_negate'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['default_portal']) && (mb_strlen($this->container['default_portal']) > 35)) {
            $invalidProperties[] = "invalid value for 'default_portal', the character length must be smaller than or equal to 35.";
        }

        if (!is_null($this->container['authentication_rule']) && (count($this->container['authentication_rule']) > 0)) {
            $invalidProperties[] = "invalid value for 'authentication_rule', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getDtlsTunnelAllowableValues();
        if (!is_null($this->container['dtls_tunnel']) && !in_array($this->container['dtls_tunnel'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'dtls_tunnel', must be one of '%s'",
                $this->container['dtls_tunnel'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDtlsMaxProtoVerAllowableValues();
        if (!is_null($this->container['dtls_max_proto_ver']) && !in_array($this->container['dtls_max_proto_ver'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'dtls_max_proto_ver', must be one of '%s'",
                $this->container['dtls_max_proto_ver'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDtlsMinProtoVerAllowableValues();
        if (!is_null($this->container['dtls_min_proto_ver']) && !in_array($this->container['dtls_min_proto_ver'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'dtls_min_proto_ver', must be one of '%s'",
                $this->container['dtls_min_proto_ver'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCheckRefererAllowableValues();
        if (!is_null($this->container['check_referer']) && !in_array($this->container['check_referer'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'check_referer', must be one of '%s'",
                $this->container['check_referer'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['http_request_header_timeout']) && ($this->container['http_request_header_timeout'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'http_request_header_timeout', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['http_request_header_timeout']) && ($this->container['http_request_header_timeout'] < 0)) {
            $invalidProperties[] = "invalid value for 'http_request_header_timeout', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['http_request_body_timeout']) && ($this->container['http_request_body_timeout'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'http_request_body_timeout', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['http_request_body_timeout']) && ($this->container['http_request_body_timeout'] < 0)) {
            $invalidProperties[] = "invalid value for 'http_request_body_timeout', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getAuthSessionCheckSourceIpAllowableValues();
        if (!is_null($this->container['auth_session_check_source_ip']) && !in_array($this->container['auth_session_check_source_ip'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auth_session_check_source_ip', must be one of '%s'",
                $this->container['auth_session_check_source_ip'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTunnelConnectWithoutReauthAllowableValues();
        if (!is_null($this->container['tunnel_connect_without_reauth']) && !in_array($this->container['tunnel_connect_without_reauth'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'tunnel_connect_without_reauth', must be one of '%s'",
                $this->container['tunnel_connect_without_reauth'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['tunnel_user_session_timeout']) && ($this->container['tunnel_user_session_timeout'] > 255)) {
            $invalidProperties[] = "invalid value for 'tunnel_user_session_timeout', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['tunnel_user_session_timeout']) && ($this->container['tunnel_user_session_timeout'] < 1)) {
            $invalidProperties[] = "invalid value for 'tunnel_user_session_timeout', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getHstsIncludeSubdomainsAllowableValues();
        if (!is_null($this->container['hsts_include_subdomains']) && !in_array($this->container['hsts_include_subdomains'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'hsts_include_subdomains', must be one of '%s'",
                $this->container['hsts_include_subdomains'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTransformBackwardSlashesAllowableValues();
        if (!is_null($this->container['transform_backward_slashes']) && !in_array($this->container['transform_backward_slashes'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'transform_backward_slashes', must be one of '%s'",
                $this->container['transform_backward_slashes'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEncode2fSequenceAllowableValues();
        if (!is_null($this->container['encode_2f_sequence']) && !in_array($this->container['encode_2f_sequence'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'encode_2f_sequence', must be one of '%s'",
                $this->container['encode_2f_sequence'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEncryptAndStorePasswordAllowableValues();
        if (!is_null($this->container['encrypt_and_store_password']) && !in_array($this->container['encrypt_and_store_password'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'encrypt_and_store_password', must be one of '%s'",
                $this->container['encrypt_and_store_password'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getClientSigalgsAllowableValues();
        if (!is_null($this->container['client_sigalgs']) && !in_array($this->container['client_sigalgs'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'client_sigalgs', must be one of '%s'",
                $this->container['client_sigalgs'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets reqclientcert
     *
     * @return string|null
     */
    public function getReqclientcert()
    {
        return $this->container['reqclientcert'];
    }

    /**
     * Sets reqclientcert
     *
     * @param string|null $reqclientcert Enable/disable to require client certificates for all SSL VPN users.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setReqclientcert($reqclientcert)
    {
        $allowedValues = $this->getReqclientcertAllowableValues();
        if (!is_null($reqclientcert) && !in_array($reqclientcert, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'reqclientcert', must be one of '%s'",
                    $reqclientcert,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['reqclientcert'] = $reqclientcert;

        return $this;
    }

    /**
     * Gets user_peer
     *
     * @return string|null
     */
    public function getUserPeer()
    {
        return $this->container['user_peer'];
    }

    /**
     * Sets user_peer
     *
     * @param string|null $user_peer Name of user peer.
     *
     * @return self
     */
    public function setUserPeer($user_peer)
    {
        if (!is_null($user_peer) && (mb_strlen($user_peer) > 35)) {
            throw new \InvalidArgumentException('invalid length for $user_peer when calling InlineObject495., must be smaller than or equal to 35.');
        }

        $this->container['user_peer'] = $user_peer;

        return $this;
    }

    /**
     * Gets ssl_max_proto_ver
     *
     * @return string|null
     */
    public function getSslMaxProtoVer()
    {
        return $this->container['ssl_max_proto_ver'];
    }

    /**
     * Sets ssl_max_proto_ver
     *
     * @param string|null $ssl_max_proto_ver SSL maximum protocol version.    tls1-0:TLS version 1.0.    tls1-1:TLS version 1.1.    tls1-2:TLS version 1.2.    tls1-3:TLS version 1.3.
     *
     * @return self
     */
    public function setSslMaxProtoVer($ssl_max_proto_ver)
    {
        $allowedValues = $this->getSslMaxProtoVerAllowableValues();
        if (!is_null($ssl_max_proto_ver) && !in_array($ssl_max_proto_ver, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ssl_max_proto_ver', must be one of '%s'",
                    $ssl_max_proto_ver,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ssl_max_proto_ver'] = $ssl_max_proto_ver;

        return $this;
    }

    /**
     * Gets ssl_min_proto_ver
     *
     * @return string|null
     */
    public function getSslMinProtoVer()
    {
        return $this->container['ssl_min_proto_ver'];
    }

    /**
     * Sets ssl_min_proto_ver
     *
     * @param string|null $ssl_min_proto_ver SSL minimum protocol version.    tls1-0:TLS version 1.0.    tls1-1:TLS version 1.1.    tls1-2:TLS version 1.2.    tls1-3:TLS version 1.3.
     *
     * @return self
     */
    public function setSslMinProtoVer($ssl_min_proto_ver)
    {
        $allowedValues = $this->getSslMinProtoVerAllowableValues();
        if (!is_null($ssl_min_proto_ver) && !in_array($ssl_min_proto_ver, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ssl_min_proto_ver', must be one of '%s'",
                    $ssl_min_proto_ver,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ssl_min_proto_ver'] = $ssl_min_proto_ver;

        return $this;
    }

    /**
     * Gets banned_cipher
     *
     * @return string|null
     */
    public function getBannedCipher()
    {
        return $this->container['banned_cipher'];
    }

    /**
     * Sets banned_cipher
     *
     * @param string|null $banned_cipher Select one or more cipher technologies that cannot be used in SSL VPN negotiations.    RSA:Ban the use of cipher suites using RSA key.    DHE:Ban the use of cipher suites using authenticated ephemeral DH key agreement.    ECDHE:Ban the use of cipher suites using authenticated ephemeral ECDH key agreement.    DSS:Ban the use of cipher suites using DSS authentication.    ECDSA:Ban the use of cipher suites using ECDSA authentication.    AES:Ban the use of cipher suites using either 128 or 256 bit AES.    AESGCM:Ban the use of cipher suites AES in Galois Counter Mode (GCM).    CAMELLIA:Ban the use of cipher suites using either 128 or 256 bit CAMELLIA.    3DES:Ban the use of cipher suites using triple DES    SHA1:Ban the use of cipher suites using HMAC-SHA1.    SHA256:Ban the use of cipher suites using HMAC-SHA256.    SHA384:Ban the use of cipher suites using HMAC-SHA384.    STATIC:Ban the use of cipher suites using static keys.
     *
     * @return self
     */
    public function setBannedCipher($banned_cipher)
    {
        $allowedValues = $this->getBannedCipherAllowableValues();
        if (!is_null($banned_cipher) && !in_array($banned_cipher, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'banned_cipher', must be one of '%s'",
                    $banned_cipher,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['banned_cipher'] = $banned_cipher;

        return $this;
    }

    /**
     * Gets ssl_insert_empty_fragment
     *
     * @return string|null
     */
    public function getSslInsertEmptyFragment()
    {
        return $this->container['ssl_insert_empty_fragment'];
    }

    /**
     * Sets ssl_insert_empty_fragment
     *
     * @param string|null $ssl_insert_empty_fragment Enable/disable insertion of empty fragment.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSslInsertEmptyFragment($ssl_insert_empty_fragment)
    {
        $allowedValues = $this->getSslInsertEmptyFragmentAllowableValues();
        if (!is_null($ssl_insert_empty_fragment) && !in_array($ssl_insert_empty_fragment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ssl_insert_empty_fragment', must be one of '%s'",
                    $ssl_insert_empty_fragment,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ssl_insert_empty_fragment'] = $ssl_insert_empty_fragment;

        return $this;
    }

    /**
     * Gets https_redirect
     *
     * @return string|null
     */
    public function getHttpsRedirect()
    {
        return $this->container['https_redirect'];
    }

    /**
     * Sets https_redirect
     *
     * @param string|null $https_redirect Enable/disable redirect of port 80 to SSL VPN port.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setHttpsRedirect($https_redirect)
    {
        $allowedValues = $this->getHttpsRedirectAllowableValues();
        if (!is_null($https_redirect) && !in_array($https_redirect, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'https_redirect', must be one of '%s'",
                    $https_redirect,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['https_redirect'] = $https_redirect;

        return $this;
    }

    /**
     * Gets x_content_type_options
     *
     * @return string|null
     */
    public function getXContentTypeOptions()
    {
        return $this->container['x_content_type_options'];
    }

    /**
     * Sets x_content_type_options
     *
     * @param string|null $x_content_type_options Add HTTP X-Content-Type-Options header.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setXContentTypeOptions($x_content_type_options)
    {
        $allowedValues = $this->getXContentTypeOptionsAllowableValues();
        if (!is_null($x_content_type_options) && !in_array($x_content_type_options, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'x_content_type_options', must be one of '%s'",
                    $x_content_type_options,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['x_content_type_options'] = $x_content_type_options;

        return $this;
    }

    /**
     * Gets ssl_client_renegotiation
     *
     * @return string|null
     */
    public function getSslClientRenegotiation()
    {
        return $this->container['ssl_client_renegotiation'];
    }

    /**
     * Sets ssl_client_renegotiation
     *
     * @param string|null $ssl_client_renegotiation Enable/disable to allow client renegotiation by the server if the tunnel goes down.    disable:Abort any SSL connection that attempts to renegotiate.    enable:Allow a SSL client to renegotiate.
     *
     * @return self
     */
    public function setSslClientRenegotiation($ssl_client_renegotiation)
    {
        $allowedValues = $this->getSslClientRenegotiationAllowableValues();
        if (!is_null($ssl_client_renegotiation) && !in_array($ssl_client_renegotiation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'ssl_client_renegotiation', must be one of '%s'",
                    $ssl_client_renegotiation,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ssl_client_renegotiation'] = $ssl_client_renegotiation;

        return $this;
    }

    /**
     * Gets force_two_factor_auth
     *
     * @return string|null
     */
    public function getForceTwoFactorAuth()
    {
        return $this->container['force_two_factor_auth'];
    }

    /**
     * Sets force_two_factor_auth
     *
     * @param string|null $force_two_factor_auth Enable/disable only PKI users with two-factor authentication for SSL VPNs.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setForceTwoFactorAuth($force_two_factor_auth)
    {
        $allowedValues = $this->getForceTwoFactorAuthAllowableValues();
        if (!is_null($force_two_factor_auth) && !in_array($force_two_factor_auth, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'force_two_factor_auth', must be one of '%s'",
                    $force_two_factor_auth,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['force_two_factor_auth'] = $force_two_factor_auth;

        return $this;
    }

    /**
     * Gets unsafe_legacy_renegotiation
     *
     * @return string|null
     */
    public function getUnsafeLegacyRenegotiation()
    {
        return $this->container['unsafe_legacy_renegotiation'];
    }

    /**
     * Sets unsafe_legacy_renegotiation
     *
     * @param string|null $unsafe_legacy_renegotiation Enable/disable unsafe legacy re-negotiation.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setUnsafeLegacyRenegotiation($unsafe_legacy_renegotiation)
    {
        $allowedValues = $this->getUnsafeLegacyRenegotiationAllowableValues();
        if (!is_null($unsafe_legacy_renegotiation) && !in_array($unsafe_legacy_renegotiation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'unsafe_legacy_renegotiation', must be one of '%s'",
                    $unsafe_legacy_renegotiation,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['unsafe_legacy_renegotiation'] = $unsafe_legacy_renegotiation;

        return $this;
    }

    /**
     * Gets servercert
     *
     * @return string|null
     */
    public function getServercert()
    {
        return $this->container['servercert'];
    }

    /**
     * Sets servercert
     *
     * @param string|null $servercert Name of the server certificate to be used for SSL VPNs.
     *
     * @return self
     */
    public function setServercert($servercert)
    {
        if (!is_null($servercert) && (mb_strlen($servercert) > 35)) {
            throw new \InvalidArgumentException('invalid length for $servercert when calling InlineObject495., must be smaller than or equal to 35.');
        }

        $this->container['servercert'] = $servercert;

        return $this;
    }

    /**
     * Gets algorithm
     *
     * @return string|null
     */
    public function getAlgorithm()
    {
        return $this->container['algorithm'];
    }

    /**
     * Sets algorithm
     *
     * @param string|null $algorithm Force the SSL VPN security level. High allows only high. Medium allows medium and high. Low allows any.    high:High algorithms.    medium:High and medium algorithms.    default:default    low:All algorithms.
     *
     * @return self
     */
    public function setAlgorithm($algorithm)
    {
        $allowedValues = $this->getAlgorithmAllowableValues();
        if (!is_null($algorithm) && !in_array($algorithm, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'algorithm', must be one of '%s'",
                    $algorithm,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['algorithm'] = $algorithm;

        return $this;
    }

    /**
     * Gets idle_timeout
     *
     * @return int|null
     */
    public function getIdleTimeout()
    {
        return $this->container['idle_timeout'];
    }

    /**
     * Sets idle_timeout
     *
     * @param int|null $idle_timeout SSL VPN disconnects if idle for specified time in seconds.
     *
     * @return self
     */
    public function setIdleTimeout($idle_timeout)
    {

        if (!is_null($idle_timeout) && ($idle_timeout > 259200)) {
            throw new \InvalidArgumentException('invalid value for $idle_timeout when calling InlineObject495., must be smaller than or equal to 259200.');
        }
        if (!is_null($idle_timeout) && ($idle_timeout < 0)) {
            throw new \InvalidArgumentException('invalid value for $idle_timeout when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['idle_timeout'] = $idle_timeout;

        return $this;
    }

    /**
     * Gets auth_timeout
     *
     * @return int|null
     */
    public function getAuthTimeout()
    {
        return $this->container['auth_timeout'];
    }

    /**
     * Sets auth_timeout
     *
     * @param int|null $auth_timeout SSL VPN authentication timeout (1 - 259200 sec (3 days), 0 for no timeout).
     *
     * @return self
     */
    public function setAuthTimeout($auth_timeout)
    {

        if (!is_null($auth_timeout) && ($auth_timeout > 259200)) {
            throw new \InvalidArgumentException('invalid value for $auth_timeout when calling InlineObject495., must be smaller than or equal to 259200.');
        }
        if (!is_null($auth_timeout) && ($auth_timeout < 0)) {
            throw new \InvalidArgumentException('invalid value for $auth_timeout when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['auth_timeout'] = $auth_timeout;

        return $this;
    }

    /**
     * Gets login_attempt_limit
     *
     * @return int|null
     */
    public function getLoginAttemptLimit()
    {
        return $this->container['login_attempt_limit'];
    }

    /**
     * Sets login_attempt_limit
     *
     * @param int|null $login_attempt_limit SSL VPN maximum login attempt times before block (0 - 10, default = 2, 0 = no limit).
     *
     * @return self
     */
    public function setLoginAttemptLimit($login_attempt_limit)
    {

        if (!is_null($login_attempt_limit) && ($login_attempt_limit > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $login_attempt_limit when calling InlineObject495., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($login_attempt_limit) && ($login_attempt_limit < 0)) {
            throw new \InvalidArgumentException('invalid value for $login_attempt_limit when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['login_attempt_limit'] = $login_attempt_limit;

        return $this;
    }

    /**
     * Gets login_block_time
     *
     * @return int|null
     */
    public function getLoginBlockTime()
    {
        return $this->container['login_block_time'];
    }

    /**
     * Sets login_block_time
     *
     * @param int|null $login_block_time Time for which a user is blocked from logging in after too many failed login attempts (0 - 86400 sec, default = 60).
     *
     * @return self
     */
    public function setLoginBlockTime($login_block_time)
    {

        if (!is_null($login_block_time) && ($login_block_time > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $login_block_time when calling InlineObject495., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($login_block_time) && ($login_block_time < 0)) {
            throw new \InvalidArgumentException('invalid value for $login_block_time when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['login_block_time'] = $login_block_time;

        return $this;
    }

    /**
     * Gets login_timeout
     *
     * @return int|null
     */
    public function getLoginTimeout()
    {
        return $this->container['login_timeout'];
    }

    /**
     * Sets login_timeout
     *
     * @param int|null $login_timeout SSLVPN maximum login timeout (10 - 180 sec, default = 30).
     *
     * @return self
     */
    public function setLoginTimeout($login_timeout)
    {

        if (!is_null($login_timeout) && ($login_timeout > 180)) {
            throw new \InvalidArgumentException('invalid value for $login_timeout when calling InlineObject495., must be smaller than or equal to 180.');
        }
        if (!is_null($login_timeout) && ($login_timeout < 10)) {
            throw new \InvalidArgumentException('invalid value for $login_timeout when calling InlineObject495., must be bigger than or equal to 10.');
        }

        $this->container['login_timeout'] = $login_timeout;

        return $this;
    }

    /**
     * Gets dtls_hello_timeout
     *
     * @return int|null
     */
    public function getDtlsHelloTimeout()
    {
        return $this->container['dtls_hello_timeout'];
    }

    /**
     * Sets dtls_hello_timeout
     *
     * @param int|null $dtls_hello_timeout SSLVPN maximum DTLS hello timeout (10 - 60 sec, default = 10).
     *
     * @return self
     */
    public function setDtlsHelloTimeout($dtls_hello_timeout)
    {

        if (!is_null($dtls_hello_timeout) && ($dtls_hello_timeout > 60)) {
            throw new \InvalidArgumentException('invalid value for $dtls_hello_timeout when calling InlineObject495., must be smaller than or equal to 60.');
        }
        if (!is_null($dtls_hello_timeout) && ($dtls_hello_timeout < 10)) {
            throw new \InvalidArgumentException('invalid value for $dtls_hello_timeout when calling InlineObject495., must be bigger than or equal to 10.');
        }

        $this->container['dtls_hello_timeout'] = $dtls_hello_timeout;

        return $this;
    }

    /**
     * Gets tunnel_ip_pools
     *
     * @return \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null
     */
    public function getTunnelIpPools()
    {
        return $this->container['tunnel_ip_pools'];
    }

    /**
     * Sets tunnel_ip_pools
     *
     * @param \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null $tunnel_ip_pools Names of the IPv4 IP Pool firewall objects that define the IP addresses reserved for remote clients.
     *
     * @return self
     */
    public function setTunnelIpPools($tunnel_ip_pools)
    {

        if (!is_null($tunnel_ip_pools) && (count($tunnel_ip_pools) > 0)) {
            throw new \InvalidArgumentException('invalid value for $tunnel_ip_pools when calling InlineObject495., number of items must be less than or equal to 0.');
        }
        $this->container['tunnel_ip_pools'] = $tunnel_ip_pools;

        return $this;
    }

    /**
     * Gets tunnel_ipv6_pools
     *
     * @return \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null
     */
    public function getTunnelIpv6Pools()
    {
        return $this->container['tunnel_ipv6_pools'];
    }

    /**
     * Sets tunnel_ipv6_pools
     *
     * @param \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null $tunnel_ipv6_pools Names of the IPv6 IP Pool firewall objects that define the IP addresses reserved for remote clients.
     *
     * @return self
     */
    public function setTunnelIpv6Pools($tunnel_ipv6_pools)
    {

        if (!is_null($tunnel_ipv6_pools) && (count($tunnel_ipv6_pools) > 0)) {
            throw new \InvalidArgumentException('invalid value for $tunnel_ipv6_pools when calling InlineObject495., number of items must be less than or equal to 0.');
        }
        $this->container['tunnel_ipv6_pools'] = $tunnel_ipv6_pools;

        return $this;
    }

    /**
     * Gets dns_suffix
     *
     * @return string|null
     */
    public function getDnsSuffix()
    {
        return $this->container['dns_suffix'];
    }

    /**
     * Sets dns_suffix
     *
     * @param string|null $dns_suffix DNS suffix used for SSL VPN clients.
     *
     * @return self
     */
    public function setDnsSuffix($dns_suffix)
    {
        if (!is_null($dns_suffix) && (mb_strlen($dns_suffix) > 253)) {
            throw new \InvalidArgumentException('invalid length for $dns_suffix when calling InlineObject495., must be smaller than or equal to 253.');
        }

        $this->container['dns_suffix'] = $dns_suffix;

        return $this;
    }

    /**
     * Gets dns_server1
     *
     * @return string|null
     */
    public function getDnsServer1()
    {
        return $this->container['dns_server1'];
    }

    /**
     * Sets dns_server1
     *
     * @param string|null $dns_server1 DNS server 1.
     *
     * @return self
     */
    public function setDnsServer1($dns_server1)
    {
        $this->container['dns_server1'] = $dns_server1;

        return $this;
    }

    /**
     * Gets dns_server2
     *
     * @return string|null
     */
    public function getDnsServer2()
    {
        return $this->container['dns_server2'];
    }

    /**
     * Sets dns_server2
     *
     * @param string|null $dns_server2 DNS server 2.
     *
     * @return self
     */
    public function setDnsServer2($dns_server2)
    {
        $this->container['dns_server2'] = $dns_server2;

        return $this;
    }

    /**
     * Gets wins_server1
     *
     * @return string|null
     */
    public function getWinsServer1()
    {
        return $this->container['wins_server1'];
    }

    /**
     * Sets wins_server1
     *
     * @param string|null $wins_server1 WINS server 1.
     *
     * @return self
     */
    public function setWinsServer1($wins_server1)
    {
        $this->container['wins_server1'] = $wins_server1;

        return $this;
    }

    /**
     * Gets wins_server2
     *
     * @return string|null
     */
    public function getWinsServer2()
    {
        return $this->container['wins_server2'];
    }

    /**
     * Sets wins_server2
     *
     * @param string|null $wins_server2 WINS server 2.
     *
     * @return self
     */
    public function setWinsServer2($wins_server2)
    {
        $this->container['wins_server2'] = $wins_server2;

        return $this;
    }

    /**
     * Gets ipv6_dns_server1
     *
     * @return string|null
     */
    public function getIpv6DnsServer1()
    {
        return $this->container['ipv6_dns_server1'];
    }

    /**
     * Sets ipv6_dns_server1
     *
     * @param string|null $ipv6_dns_server1 IPv6 DNS server 1.
     *
     * @return self
     */
    public function setIpv6DnsServer1($ipv6_dns_server1)
    {
        $this->container['ipv6_dns_server1'] = $ipv6_dns_server1;

        return $this;
    }

    /**
     * Gets ipv6_dns_server2
     *
     * @return string|null
     */
    public function getIpv6DnsServer2()
    {
        return $this->container['ipv6_dns_server2'];
    }

    /**
     * Sets ipv6_dns_server2
     *
     * @param string|null $ipv6_dns_server2 IPv6 DNS server 2.
     *
     * @return self
     */
    public function setIpv6DnsServer2($ipv6_dns_server2)
    {
        $this->container['ipv6_dns_server2'] = $ipv6_dns_server2;

        return $this;
    }

    /**
     * Gets ipv6_wins_server1
     *
     * @return string|null
     */
    public function getIpv6WinsServer1()
    {
        return $this->container['ipv6_wins_server1'];
    }

    /**
     * Sets ipv6_wins_server1
     *
     * @param string|null $ipv6_wins_server1 IPv6 WINS server 1.
     *
     * @return self
     */
    public function setIpv6WinsServer1($ipv6_wins_server1)
    {
        $this->container['ipv6_wins_server1'] = $ipv6_wins_server1;

        return $this;
    }

    /**
     * Gets ipv6_wins_server2
     *
     * @return string|null
     */
    public function getIpv6WinsServer2()
    {
        return $this->container['ipv6_wins_server2'];
    }

    /**
     * Sets ipv6_wins_server2
     *
     * @param string|null $ipv6_wins_server2 IPv6 WINS server 2.
     *
     * @return self
     */
    public function setIpv6WinsServer2($ipv6_wins_server2)
    {
        $this->container['ipv6_wins_server2'] = $ipv6_wins_server2;

        return $this;
    }

    /**
     * Gets url_obscuration
     *
     * @return string|null
     */
    public function getUrlObscuration()
    {
        return $this->container['url_obscuration'];
    }

    /**
     * Sets url_obscuration
     *
     * @param string|null $url_obscuration Enable/disable to obscure the host name of the URL of the web browser display.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setUrlObscuration($url_obscuration)
    {
        $allowedValues = $this->getUrlObscurationAllowableValues();
        if (!is_null($url_obscuration) && !in_array($url_obscuration, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'url_obscuration', must be one of '%s'",
                    $url_obscuration,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['url_obscuration'] = $url_obscuration;

        return $this;
    }

    /**
     * Gets http_compression
     *
     * @return string|null
     */
    public function getHttpCompression()
    {
        return $this->container['http_compression'];
    }

    /**
     * Sets http_compression
     *
     * @param string|null $http_compression Enable/disable to allow HTTP compression over SSL VPN tunnels.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setHttpCompression($http_compression)
    {
        $allowedValues = $this->getHttpCompressionAllowableValues();
        if (!is_null($http_compression) && !in_array($http_compression, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'http_compression', must be one of '%s'",
                    $http_compression,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['http_compression'] = $http_compression;

        return $this;
    }

    /**
     * Gets http_only_cookie
     *
     * @return string|null
     */
    public function getHttpOnlyCookie()
    {
        return $this->container['http_only_cookie'];
    }

    /**
     * Sets http_only_cookie
     *
     * @param string|null $http_only_cookie Enable/disable SSL VPN support for HttpOnly cookies.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setHttpOnlyCookie($http_only_cookie)
    {
        $allowedValues = $this->getHttpOnlyCookieAllowableValues();
        if (!is_null($http_only_cookie) && !in_array($http_only_cookie, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'http_only_cookie', must be one of '%s'",
                    $http_only_cookie,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['http_only_cookie'] = $http_only_cookie;

        return $this;
    }

    /**
     * Gets deflate_compression_level
     *
     * @return int|null
     */
    public function getDeflateCompressionLevel()
    {
        return $this->container['deflate_compression_level'];
    }

    /**
     * Sets deflate_compression_level
     *
     * @param int|null $deflate_compression_level Compression level (0~9).
     *
     * @return self
     */
    public function setDeflateCompressionLevel($deflate_compression_level)
    {

        if (!is_null($deflate_compression_level) && ($deflate_compression_level > 9)) {
            throw new \InvalidArgumentException('invalid value for $deflate_compression_level when calling InlineObject495., must be smaller than or equal to 9.');
        }
        if (!is_null($deflate_compression_level) && ($deflate_compression_level < 0)) {
            throw new \InvalidArgumentException('invalid value for $deflate_compression_level when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['deflate_compression_level'] = $deflate_compression_level;

        return $this;
    }

    /**
     * Gets deflate_min_data_size
     *
     * @return int|null
     */
    public function getDeflateMinDataSize()
    {
        return $this->container['deflate_min_data_size'];
    }

    /**
     * Sets deflate_min_data_size
     *
     * @param int|null $deflate_min_data_size Minimum amount of data that triggers compression (200 - 65535 bytes).
     *
     * @return self
     */
    public function setDeflateMinDataSize($deflate_min_data_size)
    {

        if (!is_null($deflate_min_data_size) && ($deflate_min_data_size > 65535)) {
            throw new \InvalidArgumentException('invalid value for $deflate_min_data_size when calling InlineObject495., must be smaller than or equal to 65535.');
        }
        if (!is_null($deflate_min_data_size) && ($deflate_min_data_size < 200)) {
            throw new \InvalidArgumentException('invalid value for $deflate_min_data_size when calling InlineObject495., must be bigger than or equal to 200.');
        }

        $this->container['deflate_min_data_size'] = $deflate_min_data_size;

        return $this;
    }

    /**
     * Gets port
     *
     * @return int|null
     */
    public function getPort()
    {
        return $this->container['port'];
    }

    /**
     * Sets port
     *
     * @param int|null $port SSL VPN access port (1 - 65535).
     *
     * @return self
     */
    public function setPort($port)
    {

        if (!is_null($port) && ($port > 65535)) {
            throw new \InvalidArgumentException('invalid value for $port when calling InlineObject495., must be smaller than or equal to 65535.');
        }
        if (!is_null($port) && ($port < 1)) {
            throw new \InvalidArgumentException('invalid value for $port when calling InlineObject495., must be bigger than or equal to 1.');
        }

        $this->container['port'] = $port;

        return $this;
    }

    /**
     * Gets port_precedence
     *
     * @return string|null
     */
    public function getPortPrecedence()
    {
        return $this->container['port_precedence'];
    }

    /**
     * Sets port_precedence
     *
     * @param string|null $port_precedence Enable/disable, Enable means that if SSL VPN connections are allowed on an interface admin GUI connections are blocked on that interface.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setPortPrecedence($port_precedence)
    {
        $allowedValues = $this->getPortPrecedenceAllowableValues();
        if (!is_null($port_precedence) && !in_array($port_precedence, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'port_precedence', must be one of '%s'",
                    $port_precedence,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['port_precedence'] = $port_precedence;

        return $this;
    }

    /**
     * Gets auto_tunnel_static_route
     *
     * @return string|null
     */
    public function getAutoTunnelStaticRoute()
    {
        return $this->container['auto_tunnel_static_route'];
    }

    /**
     * Sets auto_tunnel_static_route
     *
     * @param string|null $auto_tunnel_static_route Enable/disable to auto-create static routes for the SSL VPN tunnel IP addresses.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setAutoTunnelStaticRoute($auto_tunnel_static_route)
    {
        $allowedValues = $this->getAutoTunnelStaticRouteAllowableValues();
        if (!is_null($auto_tunnel_static_route) && !in_array($auto_tunnel_static_route, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auto_tunnel_static_route', must be one of '%s'",
                    $auto_tunnel_static_route,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auto_tunnel_static_route'] = $auto_tunnel_static_route;

        return $this;
    }

    /**
     * Gets header_x_forwarded_for
     *
     * @return string|null
     */
    public function getHeaderXForwardedFor()
    {
        return $this->container['header_x_forwarded_for'];
    }

    /**
     * Sets header_x_forwarded_for
     *
     * @param string|null $header_x_forwarded_for Forward the same, add, or remove HTTP header.    pass:Forward the same HTTP header.    add:Add the HTTP header.    remove:Remove the HTTP header.
     *
     * @return self
     */
    public function setHeaderXForwardedFor($header_x_forwarded_for)
    {
        $allowedValues = $this->getHeaderXForwardedForAllowableValues();
        if (!is_null($header_x_forwarded_for) && !in_array($header_x_forwarded_for, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'header_x_forwarded_for', must be one of '%s'",
                    $header_x_forwarded_for,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['header_x_forwarded_for'] = $header_x_forwarded_for;

        return $this;
    }

    /**
     * Gets source_interface
     *
     * @return \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceInterface[]|null
     */
    public function getSourceInterface()
    {
        return $this->container['source_interface'];
    }

    /**
     * Sets source_interface
     *
     * @param \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceInterface[]|null $source_interface SSL VPN source interface of incoming traffic.
     *
     * @return self
     */
    public function setSourceInterface($source_interface)
    {

        if (!is_null($source_interface) && (count($source_interface) > 0)) {
            throw new \InvalidArgumentException('invalid value for $source_interface when calling InlineObject495., number of items must be less than or equal to 0.');
        }
        $this->container['source_interface'] = $source_interface;

        return $this;
    }

    /**
     * Gets source_address
     *
     * @return \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null
     */
    public function getSourceAddress()
    {
        return $this->container['source_address'];
    }

    /**
     * Sets source_address
     *
     * @param \Fortigate\FortiOS\Model\CMDB\AuthenticationRuleNameSrcaddr[]|null $source_address Source address of incoming traffic.
     *
     * @return self
     */
    public function setSourceAddress($source_address)
    {

        if (!is_null($source_address) && (count($source_address) > 0)) {
            throw new \InvalidArgumentException('invalid value for $source_address when calling InlineObject495., number of items must be less than or equal to 0.');
        }
        $this->container['source_address'] = $source_address;

        return $this;
    }

    /**
     * Gets source_address_negate
     *
     * @return string|null
     */
    public function getSourceAddressNegate()
    {
        return $this->container['source_address_negate'];
    }

    /**
     * Sets source_address_negate
     *
     * @param string|null $source_address_negate Enable/disable negated source address match.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSourceAddressNegate($source_address_negate)
    {
        $allowedValues = $this->getSourceAddressNegateAllowableValues();
        if (!is_null($source_address_negate) && !in_array($source_address_negate, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'source_address_negate', must be one of '%s'",
                    $source_address_negate,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['source_address_negate'] = $source_address_negate;

        return $this;
    }

    /**
     * Gets source_address6
     *
     * @return \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceAddress6[]|null
     */
    public function getSourceAddress6()
    {
        return $this->container['source_address6'];
    }

    /**
     * Sets source_address6
     *
     * @param \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsSourceAddress6[]|null $source_address6 IPv6 source address of incoming traffic.
     *
     * @return self
     */
    public function setSourceAddress6($source_address6)
    {

        if (!is_null($source_address6) && (count($source_address6) > 0)) {
            throw new \InvalidArgumentException('invalid value for $source_address6 when calling InlineObject495., number of items must be less than or equal to 0.');
        }
        $this->container['source_address6'] = $source_address6;

        return $this;
    }

    /**
     * Gets source_address6_negate
     *
     * @return string|null
     */
    public function getSourceAddress6Negate()
    {
        return $this->container['source_address6_negate'];
    }

    /**
     * Sets source_address6_negate
     *
     * @param string|null $source_address6_negate Enable/disable negated source IPv6 address match.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setSourceAddress6Negate($source_address6_negate)
    {
        $allowedValues = $this->getSourceAddress6NegateAllowableValues();
        if (!is_null($source_address6_negate) && !in_array($source_address6_negate, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'source_address6_negate', must be one of '%s'",
                    $source_address6_negate,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['source_address6_negate'] = $source_address6_negate;

        return $this;
    }

    /**
     * Gets default_portal
     *
     * @return string|null
     */
    public function getDefaultPortal()
    {
        return $this->container['default_portal'];
    }

    /**
     * Sets default_portal
     *
     * @param string|null $default_portal Default SSL VPN portal.
     *
     * @return self
     */
    public function setDefaultPortal($default_portal)
    {
        if (!is_null($default_portal) && (mb_strlen($default_portal) > 35)) {
            throw new \InvalidArgumentException('invalid length for $default_portal when calling InlineObject495., must be smaller than or equal to 35.');
        }

        $this->container['default_portal'] = $default_portal;

        return $this;
    }

    /**
     * Gets authentication_rule
     *
     * @return \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsAuthenticationRule[]|null
     */
    public function getAuthenticationRule()
    {
        return $this->container['authentication_rule'];
    }

    /**
     * Sets authentication_rule
     *
     * @param \Fortigate\FortiOS\Model\CMDB\VpnSslSettingsAuthenticationRule[]|null $authentication_rule Authentication rule for SSL VPN.
     *
     * @return self
     */
    public function setAuthenticationRule($authentication_rule)
    {

        if (!is_null($authentication_rule) && (count($authentication_rule) > 0)) {
            throw new \InvalidArgumentException('invalid value for $authentication_rule when calling InlineObject495., number of items must be less than or equal to 0.');
        }
        $this->container['authentication_rule'] = $authentication_rule;

        return $this;
    }

    /**
     * Gets dtls_tunnel
     *
     * @return string|null
     */
    public function getDtlsTunnel()
    {
        return $this->container['dtls_tunnel'];
    }

    /**
     * Sets dtls_tunnel
     *
     * @param string|null $dtls_tunnel Enable/disable DTLS to prevent eavesdropping, tampering, or message forgery.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setDtlsTunnel($dtls_tunnel)
    {
        $allowedValues = $this->getDtlsTunnelAllowableValues();
        if (!is_null($dtls_tunnel) && !in_array($dtls_tunnel, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'dtls_tunnel', must be one of '%s'",
                    $dtls_tunnel,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['dtls_tunnel'] = $dtls_tunnel;

        return $this;
    }

    /**
     * Gets dtls_max_proto_ver
     *
     * @return string|null
     */
    public function getDtlsMaxProtoVer()
    {
        return $this->container['dtls_max_proto_ver'];
    }

    /**
     * Sets dtls_max_proto_ver
     *
     * @param string|null $dtls_max_proto_ver DTLS maximum protocol version.    dtls1-0:DTLS version 1.0.    dtls1-2:DTLS version 1.2.
     *
     * @return self
     */
    public function setDtlsMaxProtoVer($dtls_max_proto_ver)
    {
        $allowedValues = $this->getDtlsMaxProtoVerAllowableValues();
        if (!is_null($dtls_max_proto_ver) && !in_array($dtls_max_proto_ver, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'dtls_max_proto_ver', must be one of '%s'",
                    $dtls_max_proto_ver,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['dtls_max_proto_ver'] = $dtls_max_proto_ver;

        return $this;
    }

    /**
     * Gets dtls_min_proto_ver
     *
     * @return string|null
     */
    public function getDtlsMinProtoVer()
    {
        return $this->container['dtls_min_proto_ver'];
    }

    /**
     * Sets dtls_min_proto_ver
     *
     * @param string|null $dtls_min_proto_ver DTLS minimum protocol version.    dtls1-0:DTLS version 1.0.    dtls1-2:DTLS version 1.2.
     *
     * @return self
     */
    public function setDtlsMinProtoVer($dtls_min_proto_ver)
    {
        $allowedValues = $this->getDtlsMinProtoVerAllowableValues();
        if (!is_null($dtls_min_proto_ver) && !in_array($dtls_min_proto_ver, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'dtls_min_proto_ver', must be one of '%s'",
                    $dtls_min_proto_ver,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['dtls_min_proto_ver'] = $dtls_min_proto_ver;

        return $this;
    }

    /**
     * Gets check_referer
     *
     * @return string|null
     */
    public function getCheckReferer()
    {
        return $this->container['check_referer'];
    }

    /**
     * Sets check_referer
     *
     * @param string|null $check_referer Enable/disable verification of referer field in HTTP request header.    enable:Enable verification of referer field in HTTP request header.    disable:Disable verification of referer field in HTTP request header.
     *
     * @return self
     */
    public function setCheckReferer($check_referer)
    {
        $allowedValues = $this->getCheckRefererAllowableValues();
        if (!is_null($check_referer) && !in_array($check_referer, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'check_referer', must be one of '%s'",
                    $check_referer,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['check_referer'] = $check_referer;

        return $this;
    }

    /**
     * Gets http_request_header_timeout
     *
     * @return int|null
     */
    public function getHttpRequestHeaderTimeout()
    {
        return $this->container['http_request_header_timeout'];
    }

    /**
     * Sets http_request_header_timeout
     *
     * @param int|null $http_request_header_timeout SSL VPN session is disconnected if an HTTP request header is not received within this time (1 - 60 sec, default = 20).
     *
     * @return self
     */
    public function setHttpRequestHeaderTimeout($http_request_header_timeout)
    {

        if (!is_null($http_request_header_timeout) && ($http_request_header_timeout > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $http_request_header_timeout when calling InlineObject495., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($http_request_header_timeout) && ($http_request_header_timeout < 0)) {
            throw new \InvalidArgumentException('invalid value for $http_request_header_timeout when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['http_request_header_timeout'] = $http_request_header_timeout;

        return $this;
    }

    /**
     * Gets http_request_body_timeout
     *
     * @return int|null
     */
    public function getHttpRequestBodyTimeout()
    {
        return $this->container['http_request_body_timeout'];
    }

    /**
     * Sets http_request_body_timeout
     *
     * @param int|null $http_request_body_timeout SSL VPN session is disconnected if an HTTP request body is not received within this time (1 - 60 sec, default = 20).
     *
     * @return self
     */
    public function setHttpRequestBodyTimeout($http_request_body_timeout)
    {

        if (!is_null($http_request_body_timeout) && ($http_request_body_timeout > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $http_request_body_timeout when calling InlineObject495., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($http_request_body_timeout) && ($http_request_body_timeout < 0)) {
            throw new \InvalidArgumentException('invalid value for $http_request_body_timeout when calling InlineObject495., must be bigger than or equal to 0.');
        }

        $this->container['http_request_body_timeout'] = $http_request_body_timeout;

        return $this;
    }

    /**
     * Gets auth_session_check_source_ip
     *
     * @return string|null
     */
    public function getAuthSessionCheckSourceIp()
    {
        return $this->container['auth_session_check_source_ip'];
    }

    /**
     * Sets auth_session_check_source_ip
     *
     * @param string|null $auth_session_check_source_ip Enable/disable checking of source IP for authentication session.    enable:Enable checking of source IP for authentication session.    disable:Disable checking of source IP for authentication session.
     *
     * @return self
     */
    public function setAuthSessionCheckSourceIp($auth_session_check_source_ip)
    {
        $allowedValues = $this->getAuthSessionCheckSourceIpAllowableValues();
        if (!is_null($auth_session_check_source_ip) && !in_array($auth_session_check_source_ip, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auth_session_check_source_ip', must be one of '%s'",
                    $auth_session_check_source_ip,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_session_check_source_ip'] = $auth_session_check_source_ip;

        return $this;
    }

    /**
     * Gets tunnel_connect_without_reauth
     *
     * @return string|null
     */
    public function getTunnelConnectWithoutReauth()
    {
        return $this->container['tunnel_connect_without_reauth'];
    }

    /**
     * Sets tunnel_connect_without_reauth
     *
     * @param string|null $tunnel_connect_without_reauth Enable/disable tunnel connection without re-authorization if previous connection dropped.    enable:Enable tunnel connection without re-authorization.    disable:Disable tunnel connection without re-authorization.
     *
     * @return self
     */
    public function setTunnelConnectWithoutReauth($tunnel_connect_without_reauth)
    {
        $allowedValues = $this->getTunnelConnectWithoutReauthAllowableValues();
        if (!is_null($tunnel_connect_without_reauth) && !in_array($tunnel_connect_without_reauth, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'tunnel_connect_without_reauth', must be one of '%s'",
                    $tunnel_connect_without_reauth,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tunnel_connect_without_reauth'] = $tunnel_connect_without_reauth;

        return $this;
    }

    /**
     * Gets tunnel_user_session_timeout
     *
     * @return int|null
     */
    public function getTunnelUserSessionTimeout()
    {
        return $this->container['tunnel_user_session_timeout'];
    }

    /**
     * Sets tunnel_user_session_timeout
     *
     * @param int|null $tunnel_user_session_timeout Time out value to clean up user session after tunnel connection is dropped (1 - 255 sec, default=30).
     *
     * @return self
     */
    public function setTunnelUserSessionTimeout($tunnel_user_session_timeout)
    {

        if (!is_null($tunnel_user_session_timeout) && ($tunnel_user_session_timeout > 255)) {
            throw new \InvalidArgumentException('invalid value for $tunnel_user_session_timeout when calling InlineObject495., must be smaller than or equal to 255.');
        }
        if (!is_null($tunnel_user_session_timeout) && ($tunnel_user_session_timeout < 1)) {
            throw new \InvalidArgumentException('invalid value for $tunnel_user_session_timeout when calling InlineObject495., must be bigger than or equal to 1.');
        }

        $this->container['tunnel_user_session_timeout'] = $tunnel_user_session_timeout;

        return $this;
    }

    /**
     * Gets hsts_include_subdomains
     *
     * @return string|null
     */
    public function getHstsIncludeSubdomains()
    {
        return $this->container['hsts_include_subdomains'];
    }

    /**
     * Sets hsts_include_subdomains
     *
     * @param string|null $hsts_include_subdomains Add HSTS includeSubDomains response header.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setHstsIncludeSubdomains($hsts_include_subdomains)
    {
        $allowedValues = $this->getHstsIncludeSubdomainsAllowableValues();
        if (!is_null($hsts_include_subdomains) && !in_array($hsts_include_subdomains, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'hsts_include_subdomains', must be one of '%s'",
                    $hsts_include_subdomains,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['hsts_include_subdomains'] = $hsts_include_subdomains;

        return $this;
    }

    /**
     * Gets transform_backward_slashes
     *
     * @return string|null
     */
    public function getTransformBackwardSlashes()
    {
        return $this->container['transform_backward_slashes'];
    }

    /**
     * Sets transform_backward_slashes
     *
     * @param string|null $transform_backward_slashes Transform backward slashes to forward slashes in URLs.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setTransformBackwardSlashes($transform_backward_slashes)
    {
        $allowedValues = $this->getTransformBackwardSlashesAllowableValues();
        if (!is_null($transform_backward_slashes) && !in_array($transform_backward_slashes, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'transform_backward_slashes', must be one of '%s'",
                    $transform_backward_slashes,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['transform_backward_slashes'] = $transform_backward_slashes;

        return $this;
    }

    /**
     * Gets encode_2f_sequence
     *
     * @return string|null
     */
    public function getEncode2fSequence()
    {
        return $this->container['encode_2f_sequence'];
    }

    /**
     * Sets encode_2f_sequence
     *
     * @param string|null $encode_2f_sequence Encode \\2F sequence to forward slash in URLs.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setEncode2fSequence($encode_2f_sequence)
    {
        $allowedValues = $this->getEncode2fSequenceAllowableValues();
        if (!is_null($encode_2f_sequence) && !in_array($encode_2f_sequence, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'encode_2f_sequence', must be one of '%s'",
                    $encode_2f_sequence,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['encode_2f_sequence'] = $encode_2f_sequence;

        return $this;
    }

    /**
     * Gets encrypt_and_store_password
     *
     * @return string|null
     */
    public function getEncryptAndStorePassword()
    {
        return $this->container['encrypt_and_store_password'];
    }

    /**
     * Sets encrypt_and_store_password
     *
     * @param string|null $encrypt_and_store_password Encrypt and store user passwords for SSL VPN web sessions.    enable:Enable setting.    disable:Disable setting.
     *
     * @return self
     */
    public function setEncryptAndStorePassword($encrypt_and_store_password)
    {
        $allowedValues = $this->getEncryptAndStorePasswordAllowableValues();
        if (!is_null($encrypt_and_store_password) && !in_array($encrypt_and_store_password, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'encrypt_and_store_password', must be one of '%s'",
                    $encrypt_and_store_password,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['encrypt_and_store_password'] = $encrypt_and_store_password;

        return $this;
    }

    /**
     * Gets client_sigalgs
     *
     * @return string|null
     */
    public function getClientSigalgs()
    {
        return $this->container['client_sigalgs'];
    }

    /**
     * Sets client_sigalgs
     *
     * @param string|null $client_sigalgs Set signature algorithms related to client authentication. Affects TLS version <= 1.2 only.    no-rsa-pss:Disable RSA-PSS signature algorithms for client authentication.    all:Enable all supported signature algorithms for client authentication.
     *
     * @return self
     */
    public function setClientSigalgs($client_sigalgs)
    {
        $allowedValues = $this->getClientSigalgsAllowableValues();
        if (!is_null($client_sigalgs) && !in_array($client_sigalgs, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'client_sigalgs', must be one of '%s'",
                    $client_sigalgs,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['client_sigalgs'] = $client_sigalgs;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


