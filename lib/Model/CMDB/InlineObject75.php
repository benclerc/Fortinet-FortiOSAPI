<?php
/**
 * InlineObject75
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * InlineObject75 Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class InlineObject75 implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'inline_object_75';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'fail_open' => 'string',
        'database' => 'string',
        'traffic_submit' => 'string',
        'anomaly_mode' => 'string',
        'session_limit_mode' => 'string',
        'socket_size' => 'int',
        'engine_count' => 'int',
        'sync_session_ttl' => 'string',
        'np_accel_mode' => 'string',
        'cp_accel_mode' => 'string',
        'deep_app_insp_timeout' => 'int',
        'deep_app_insp_db_limit' => 'int',
        'exclude_signatures' => 'string',
        'packet_log_queue_depth' => 'int',
        'ngfw_max_scan_range' => 'int',
        'tls_active_probe' => '\Fortigate\FortiOS\Model\CMDB\IpsGlobalTlsActiveProbe[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'fail_open' => null,
        'database' => null,
        'traffic_submit' => null,
        'anomaly_mode' => null,
        'session_limit_mode' => null,
        'socket_size' => null,
        'engine_count' => null,
        'sync_session_ttl' => null,
        'np_accel_mode' => null,
        'cp_accel_mode' => null,
        'deep_app_insp_timeout' => null,
        'deep_app_insp_db_limit' => null,
        'exclude_signatures' => null,
        'packet_log_queue_depth' => null,
        'ngfw_max_scan_range' => null,
        'tls_active_probe' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'fail_open' => 'fail-open',
        'database' => 'database',
        'traffic_submit' => 'traffic-submit',
        'anomaly_mode' => 'anomaly-mode',
        'session_limit_mode' => 'session-limit-mode',
        'socket_size' => 'socket-size',
        'engine_count' => 'engine-count',
        'sync_session_ttl' => 'sync-session-ttl',
        'np_accel_mode' => 'np-accel-mode',
        'cp_accel_mode' => 'cp-accel-mode',
        'deep_app_insp_timeout' => 'deep-app-insp-timeout',
        'deep_app_insp_db_limit' => 'deep-app-insp-db-limit',
        'exclude_signatures' => 'exclude-signatures',
        'packet_log_queue_depth' => 'packet-log-queue-depth',
        'ngfw_max_scan_range' => 'ngfw-max-scan-range',
        'tls_active_probe' => 'tls-active-probe'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'fail_open' => 'setFailOpen',
        'database' => 'setDatabase',
        'traffic_submit' => 'setTrafficSubmit',
        'anomaly_mode' => 'setAnomalyMode',
        'session_limit_mode' => 'setSessionLimitMode',
        'socket_size' => 'setSocketSize',
        'engine_count' => 'setEngineCount',
        'sync_session_ttl' => 'setSyncSessionTtl',
        'np_accel_mode' => 'setNpAccelMode',
        'cp_accel_mode' => 'setCpAccelMode',
        'deep_app_insp_timeout' => 'setDeepAppInspTimeout',
        'deep_app_insp_db_limit' => 'setDeepAppInspDbLimit',
        'exclude_signatures' => 'setExcludeSignatures',
        'packet_log_queue_depth' => 'setPacketLogQueueDepth',
        'ngfw_max_scan_range' => 'setNgfwMaxScanRange',
        'tls_active_probe' => 'setTlsActiveProbe'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'fail_open' => 'getFailOpen',
        'database' => 'getDatabase',
        'traffic_submit' => 'getTrafficSubmit',
        'anomaly_mode' => 'getAnomalyMode',
        'session_limit_mode' => 'getSessionLimitMode',
        'socket_size' => 'getSocketSize',
        'engine_count' => 'getEngineCount',
        'sync_session_ttl' => 'getSyncSessionTtl',
        'np_accel_mode' => 'getNpAccelMode',
        'cp_accel_mode' => 'getCpAccelMode',
        'deep_app_insp_timeout' => 'getDeepAppInspTimeout',
        'deep_app_insp_db_limit' => 'getDeepAppInspDbLimit',
        'exclude_signatures' => 'getExcludeSignatures',
        'packet_log_queue_depth' => 'getPacketLogQueueDepth',
        'ngfw_max_scan_range' => 'getNgfwMaxScanRange',
        'tls_active_probe' => 'getTlsActiveProbe'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const FAIL_OPEN_ENABLE = 'enable';
    const FAIL_OPEN_DISABLE = 'disable';
    const DATABASE_REGULAR = 'regular';
    const DATABASE_EXTENDED = 'extended';
    const TRAFFIC_SUBMIT_ENABLE = 'enable';
    const TRAFFIC_SUBMIT_DISABLE = 'disable';
    const ANOMALY_MODE_PERIODICAL = 'periodical';
    const ANOMALY_MODE_CONTINUOUS = 'continuous';
    const SESSION_LIMIT_MODE_ACCURATE = 'accurate';
    const SESSION_LIMIT_MODE_HEURISTIC = 'heuristic';
    const SYNC_SESSION_TTL_ENABLE = 'enable';
    const SYNC_SESSION_TTL_DISABLE = 'disable';
    const NP_ACCEL_MODE_NONE = 'none';
    const NP_ACCEL_MODE_BASIC = 'basic';
    const CP_ACCEL_MODE_NONE = 'none';
    const CP_ACCEL_MODE_BASIC = 'basic';
    const CP_ACCEL_MODE_ADVANCED = 'advanced';
    const EXCLUDE_SIGNATURES_NONE = 'none';
    const EXCLUDE_SIGNATURES_INDUSTRIAL = 'industrial';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFailOpenAllowableValues()
    {
        return [
            self::FAIL_OPEN_ENABLE,
            self::FAIL_OPEN_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDatabaseAllowableValues()
    {
        return [
            self::DATABASE_REGULAR,
            self::DATABASE_EXTENDED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTrafficSubmitAllowableValues()
    {
        return [
            self::TRAFFIC_SUBMIT_ENABLE,
            self::TRAFFIC_SUBMIT_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAnomalyModeAllowableValues()
    {
        return [
            self::ANOMALY_MODE_PERIODICAL,
            self::ANOMALY_MODE_CONTINUOUS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSessionLimitModeAllowableValues()
    {
        return [
            self::SESSION_LIMIT_MODE_ACCURATE,
            self::SESSION_LIMIT_MODE_HEURISTIC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSyncSessionTtlAllowableValues()
    {
        return [
            self::SYNC_SESSION_TTL_ENABLE,
            self::SYNC_SESSION_TTL_DISABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getNpAccelModeAllowableValues()
    {
        return [
            self::NP_ACCEL_MODE_NONE,
            self::NP_ACCEL_MODE_BASIC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCpAccelModeAllowableValues()
    {
        return [
            self::CP_ACCEL_MODE_NONE,
            self::CP_ACCEL_MODE_BASIC,
            self::CP_ACCEL_MODE_ADVANCED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getExcludeSignaturesAllowableValues()
    {
        return [
            self::EXCLUDE_SIGNATURES_NONE,
            self::EXCLUDE_SIGNATURES_INDUSTRIAL,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['fail_open'] = $data['fail_open'] ?? null;
        $this->container['database'] = $data['database'] ?? null;
        $this->container['traffic_submit'] = $data['traffic_submit'] ?? null;
        $this->container['anomaly_mode'] = $data['anomaly_mode'] ?? null;
        $this->container['session_limit_mode'] = $data['session_limit_mode'] ?? null;
        $this->container['socket_size'] = $data['socket_size'] ?? null;
        $this->container['engine_count'] = $data['engine_count'] ?? null;
        $this->container['sync_session_ttl'] = $data['sync_session_ttl'] ?? null;
        $this->container['np_accel_mode'] = $data['np_accel_mode'] ?? null;
        $this->container['cp_accel_mode'] = $data['cp_accel_mode'] ?? null;
        $this->container['deep_app_insp_timeout'] = $data['deep_app_insp_timeout'] ?? null;
        $this->container['deep_app_insp_db_limit'] = $data['deep_app_insp_db_limit'] ?? null;
        $this->container['exclude_signatures'] = $data['exclude_signatures'] ?? null;
        $this->container['packet_log_queue_depth'] = $data['packet_log_queue_depth'] ?? null;
        $this->container['ngfw_max_scan_range'] = $data['ngfw_max_scan_range'] ?? null;
        $this->container['tls_active_probe'] = $data['tls_active_probe'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getFailOpenAllowableValues();
        if (!is_null($this->container['fail_open']) && !in_array($this->container['fail_open'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'fail_open', must be one of '%s'",
                $this->container['fail_open'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDatabaseAllowableValues();
        if (!is_null($this->container['database']) && !in_array($this->container['database'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'database', must be one of '%s'",
                $this->container['database'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTrafficSubmitAllowableValues();
        if (!is_null($this->container['traffic_submit']) && !in_array($this->container['traffic_submit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'traffic_submit', must be one of '%s'",
                $this->container['traffic_submit'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAnomalyModeAllowableValues();
        if (!is_null($this->container['anomaly_mode']) && !in_array($this->container['anomaly_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'anomaly_mode', must be one of '%s'",
                $this->container['anomaly_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSessionLimitModeAllowableValues();
        if (!is_null($this->container['session_limit_mode']) && !in_array($this->container['session_limit_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'session_limit_mode', must be one of '%s'",
                $this->container['session_limit_mode'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['socket_size']) && ($this->container['socket_size'] > 128)) {
            $invalidProperties[] = "invalid value for 'socket_size', must be smaller than or equal to 128.";
        }

        if (!is_null($this->container['socket_size']) && ($this->container['socket_size'] < 0)) {
            $invalidProperties[] = "invalid value for 'socket_size', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['engine_count']) && ($this->container['engine_count'] > 255)) {
            $invalidProperties[] = "invalid value for 'engine_count', must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['engine_count']) && ($this->container['engine_count'] < 0)) {
            $invalidProperties[] = "invalid value for 'engine_count', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getSyncSessionTtlAllowableValues();
        if (!is_null($this->container['sync_session_ttl']) && !in_array($this->container['sync_session_ttl'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'sync_session_ttl', must be one of '%s'",
                $this->container['sync_session_ttl'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getNpAccelModeAllowableValues();
        if (!is_null($this->container['np_accel_mode']) && !in_array($this->container['np_accel_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'np_accel_mode', must be one of '%s'",
                $this->container['np_accel_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCpAccelModeAllowableValues();
        if (!is_null($this->container['cp_accel_mode']) && !in_array($this->container['cp_accel_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'cp_accel_mode', must be one of '%s'",
                $this->container['cp_accel_mode'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['deep_app_insp_timeout']) && ($this->container['deep_app_insp_timeout'] > 2147483647)) {
            $invalidProperties[] = "invalid value for 'deep_app_insp_timeout', must be smaller than or equal to 2147483647.";
        }

        if (!is_null($this->container['deep_app_insp_timeout']) && ($this->container['deep_app_insp_timeout'] < 0)) {
            $invalidProperties[] = "invalid value for 'deep_app_insp_timeout', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['deep_app_insp_db_limit']) && ($this->container['deep_app_insp_db_limit'] > 2147483647)) {
            $invalidProperties[] = "invalid value for 'deep_app_insp_db_limit', must be smaller than or equal to 2147483647.";
        }

        if (!is_null($this->container['deep_app_insp_db_limit']) && ($this->container['deep_app_insp_db_limit'] < 0)) {
            $invalidProperties[] = "invalid value for 'deep_app_insp_db_limit', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getExcludeSignaturesAllowableValues();
        if (!is_null($this->container['exclude_signatures']) && !in_array($this->container['exclude_signatures'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'exclude_signatures', must be one of '%s'",
                $this->container['exclude_signatures'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['packet_log_queue_depth']) && ($this->container['packet_log_queue_depth'] > 4096)) {
            $invalidProperties[] = "invalid value for 'packet_log_queue_depth', must be smaller than or equal to 4096.";
        }

        if (!is_null($this->container['packet_log_queue_depth']) && ($this->container['packet_log_queue_depth'] < 128)) {
            $invalidProperties[] = "invalid value for 'packet_log_queue_depth', must be bigger than or equal to 128.";
        }

        if (!is_null($this->container['ngfw_max_scan_range']) && ($this->container['ngfw_max_scan_range'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'ngfw_max_scan_range', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['ngfw_max_scan_range']) && ($this->container['ngfw_max_scan_range'] < 0)) {
            $invalidProperties[] = "invalid value for 'ngfw_max_scan_range', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['tls_active_probe']) && (count($this->container['tls_active_probe']) > 0)) {
            $invalidProperties[] = "invalid value for 'tls_active_probe', number of items must be less than or equal to 0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets fail_open
     *
     * @return string|null
     */
    public function getFailOpen()
    {
        return $this->container['fail_open'];
    }

    /**
     * Sets fail_open
     *
     * @param string|null $fail_open Enable to allow traffic if the IPS process crashes. Default is disable and IPS traffic is blocked when the IPS process crashes.    enable:Enable IPS fail open.    disable:Disable IPS fail open.
     *
     * @return self
     */
    public function setFailOpen($fail_open)
    {
        $allowedValues = $this->getFailOpenAllowableValues();
        if (!is_null($fail_open) && !in_array($fail_open, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'fail_open', must be one of '%s'",
                    $fail_open,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fail_open'] = $fail_open;

        return $this;
    }

    /**
     * Gets database
     *
     * @return string|null
     */
    public function getDatabase()
    {
        return $this->container['database'];
    }

    /**
     * Sets database
     *
     * @param string|null $database Regular or extended IPS database. Regular protects against the latest common and in-the-wild attacks. Extended includes protection from legacy attacks.    regular:IPS regular database package.    extended:IPS extended database package.
     *
     * @return self
     */
    public function setDatabase($database)
    {
        $allowedValues = $this->getDatabaseAllowableValues();
        if (!is_null($database) && !in_array($database, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'database', must be one of '%s'",
                    $database,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['database'] = $database;

        return $this;
    }

    /**
     * Gets traffic_submit
     *
     * @return string|null
     */
    public function getTrafficSubmit()
    {
        return $this->container['traffic_submit'];
    }

    /**
     * Sets traffic_submit
     *
     * @param string|null $traffic_submit Enable/disable submitting attack data found by this FortiGate to FortiGuard.    enable:Enable traffic submit.    disable:Disable traffic submit.
     *
     * @return self
     */
    public function setTrafficSubmit($traffic_submit)
    {
        $allowedValues = $this->getTrafficSubmitAllowableValues();
        if (!is_null($traffic_submit) && !in_array($traffic_submit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'traffic_submit', must be one of '%s'",
                    $traffic_submit,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['traffic_submit'] = $traffic_submit;

        return $this;
    }

    /**
     * Gets anomaly_mode
     *
     * @return string|null
     */
    public function getAnomalyMode()
    {
        return $this->container['anomaly_mode'];
    }

    /**
     * Sets anomaly_mode
     *
     * @param string|null $anomaly_mode Global blocking mode for rate-based anomalies.    periodical:After an anomaly is detected, allow the number of packets per second according to the anomaly configuration.    continuous:Block packets once an anomaly is detected. Overrides individual anomaly settings.
     *
     * @return self
     */
    public function setAnomalyMode($anomaly_mode)
    {
        $allowedValues = $this->getAnomalyModeAllowableValues();
        if (!is_null($anomaly_mode) && !in_array($anomaly_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'anomaly_mode', must be one of '%s'",
                    $anomaly_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['anomaly_mode'] = $anomaly_mode;

        return $this;
    }

    /**
     * Gets session_limit_mode
     *
     * @return string|null
     */
    public function getSessionLimitMode()
    {
        return $this->container['session_limit_mode'];
    }

    /**
     * Sets session_limit_mode
     *
     * @param string|null $session_limit_mode Method of counting concurrent sessions used by session limit anomalies. Choose between greater accuracy (accurate) or improved performance (heuristics).    accurate:Accurately count concurrent sessions, demands more resources.    heuristic:Use heuristics to estimate the number of concurrent sessions. Acceptable in most cases.
     *
     * @return self
     */
    public function setSessionLimitMode($session_limit_mode)
    {
        $allowedValues = $this->getSessionLimitModeAllowableValues();
        if (!is_null($session_limit_mode) && !in_array($session_limit_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'session_limit_mode', must be one of '%s'",
                    $session_limit_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['session_limit_mode'] = $session_limit_mode;

        return $this;
    }

    /**
     * Gets socket_size
     *
     * @return int|null
     */
    public function getSocketSize()
    {
        return $this->container['socket_size'];
    }

    /**
     * Sets socket_size
     *
     * @param int|null $socket_size IPS socket buffer size. Max and default value depend on available memory. Can be changed to tune performance.
     *
     * @return self
     */
    public function setSocketSize($socket_size)
    {

        if (!is_null($socket_size) && ($socket_size > 128)) {
            throw new \InvalidArgumentException('invalid value for $socket_size when calling InlineObject75., must be smaller than or equal to 128.');
        }
        if (!is_null($socket_size) && ($socket_size < 0)) {
            throw new \InvalidArgumentException('invalid value for $socket_size when calling InlineObject75., must be bigger than or equal to 0.');
        }

        $this->container['socket_size'] = $socket_size;

        return $this;
    }

    /**
     * Gets engine_count
     *
     * @return int|null
     */
    public function getEngineCount()
    {
        return $this->container['engine_count'];
    }

    /**
     * Sets engine_count
     *
     * @param int|null $engine_count Number of IPS engines running. If set to the default value of 0, FortiOS sets the number to optimize performance depending on the number of CPU cores.
     *
     * @return self
     */
    public function setEngineCount($engine_count)
    {

        if (!is_null($engine_count) && ($engine_count > 255)) {
            throw new \InvalidArgumentException('invalid value for $engine_count when calling InlineObject75., must be smaller than or equal to 255.');
        }
        if (!is_null($engine_count) && ($engine_count < 0)) {
            throw new \InvalidArgumentException('invalid value for $engine_count when calling InlineObject75., must be bigger than or equal to 0.');
        }

        $this->container['engine_count'] = $engine_count;

        return $this;
    }

    /**
     * Gets sync_session_ttl
     *
     * @return string|null
     */
    public function getSyncSessionTtl()
    {
        return $this->container['sync_session_ttl'];
    }

    /**
     * Sets sync_session_ttl
     *
     * @param string|null $sync_session_ttl Enable/disable use of kernel session TTL for IPS sessions.    enable:Enable use of kernel session TTL for IPS sessions.    disable:Disable use of kernel session TTL for IPS sessions.
     *
     * @return self
     */
    public function setSyncSessionTtl($sync_session_ttl)
    {
        $allowedValues = $this->getSyncSessionTtlAllowableValues();
        if (!is_null($sync_session_ttl) && !in_array($sync_session_ttl, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'sync_session_ttl', must be one of '%s'",
                    $sync_session_ttl,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sync_session_ttl'] = $sync_session_ttl;

        return $this;
    }

    /**
     * Gets np_accel_mode
     *
     * @return string|null
     */
    public function getNpAccelMode()
    {
        return $this->container['np_accel_mode'];
    }

    /**
     * Sets np_accel_mode
     *
     * @param string|null $np_accel_mode Acceleration mode for IPS processing by NPx processors.    none:NPx acceleration disabled.    basic:NPx acceleration enabled.
     *
     * @return self
     */
    public function setNpAccelMode($np_accel_mode)
    {
        $allowedValues = $this->getNpAccelModeAllowableValues();
        if (!is_null($np_accel_mode) && !in_array($np_accel_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'np_accel_mode', must be one of '%s'",
                    $np_accel_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['np_accel_mode'] = $np_accel_mode;

        return $this;
    }

    /**
     * Gets cp_accel_mode
     *
     * @return string|null
     */
    public function getCpAccelMode()
    {
        return $this->container['cp_accel_mode'];
    }

    /**
     * Sets cp_accel_mode
     *
     * @param string|null $cp_accel_mode IPS Pattern matching acceleration/offloading to CPx processors.    none:CPx acceleration/offloading disabled.    basic:Offload basic pattern matching to CPx processors.    advanced:Offload more types of pattern matching resulting in higher throughput than basic mode. Requires two CP8s or one CP9.
     *
     * @return self
     */
    public function setCpAccelMode($cp_accel_mode)
    {
        $allowedValues = $this->getCpAccelModeAllowableValues();
        if (!is_null($cp_accel_mode) && !in_array($cp_accel_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'cp_accel_mode', must be one of '%s'",
                    $cp_accel_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cp_accel_mode'] = $cp_accel_mode;

        return $this;
    }

    /**
     * Gets deep_app_insp_timeout
     *
     * @return int|null
     */
    public function getDeepAppInspTimeout()
    {
        return $this->container['deep_app_insp_timeout'];
    }

    /**
     * Sets deep_app_insp_timeout
     *
     * @param int|null $deep_app_insp_timeout Timeout for Deep application inspection (1 - 2147483647 sec., 0 = use recommended setting).
     *
     * @return self
     */
    public function setDeepAppInspTimeout($deep_app_insp_timeout)
    {

        if (!is_null($deep_app_insp_timeout) && ($deep_app_insp_timeout > 2147483647)) {
            throw new \InvalidArgumentException('invalid value for $deep_app_insp_timeout when calling InlineObject75., must be smaller than or equal to 2147483647.');
        }
        if (!is_null($deep_app_insp_timeout) && ($deep_app_insp_timeout < 0)) {
            throw new \InvalidArgumentException('invalid value for $deep_app_insp_timeout when calling InlineObject75., must be bigger than or equal to 0.');
        }

        $this->container['deep_app_insp_timeout'] = $deep_app_insp_timeout;

        return $this;
    }

    /**
     * Gets deep_app_insp_db_limit
     *
     * @return int|null
     */
    public function getDeepAppInspDbLimit()
    {
        return $this->container['deep_app_insp_db_limit'];
    }

    /**
     * Sets deep_app_insp_db_limit
     *
     * @param int|null $deep_app_insp_db_limit Limit on number of entries in deep application inspection database (1 - 2147483647, 0 = use recommended setting)
     *
     * @return self
     */
    public function setDeepAppInspDbLimit($deep_app_insp_db_limit)
    {

        if (!is_null($deep_app_insp_db_limit) && ($deep_app_insp_db_limit > 2147483647)) {
            throw new \InvalidArgumentException('invalid value for $deep_app_insp_db_limit when calling InlineObject75., must be smaller than or equal to 2147483647.');
        }
        if (!is_null($deep_app_insp_db_limit) && ($deep_app_insp_db_limit < 0)) {
            throw new \InvalidArgumentException('invalid value for $deep_app_insp_db_limit when calling InlineObject75., must be bigger than or equal to 0.');
        }

        $this->container['deep_app_insp_db_limit'] = $deep_app_insp_db_limit;

        return $this;
    }

    /**
     * Gets exclude_signatures
     *
     * @return string|null
     */
    public function getExcludeSignatures()
    {
        return $this->container['exclude_signatures'];
    }

    /**
     * Sets exclude_signatures
     *
     * @param string|null $exclude_signatures Excluded signatures.    none:No signatures excluded.    industrial:Exclude industrial signatures.
     *
     * @return self
     */
    public function setExcludeSignatures($exclude_signatures)
    {
        $allowedValues = $this->getExcludeSignaturesAllowableValues();
        if (!is_null($exclude_signatures) && !in_array($exclude_signatures, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'exclude_signatures', must be one of '%s'",
                    $exclude_signatures,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['exclude_signatures'] = $exclude_signatures;

        return $this;
    }

    /**
     * Gets packet_log_queue_depth
     *
     * @return int|null
     */
    public function getPacketLogQueueDepth()
    {
        return $this->container['packet_log_queue_depth'];
    }

    /**
     * Sets packet_log_queue_depth
     *
     * @param int|null $packet_log_queue_depth Packet/pcap log queue depth per IPS engine.
     *
     * @return self
     */
    public function setPacketLogQueueDepth($packet_log_queue_depth)
    {

        if (!is_null($packet_log_queue_depth) && ($packet_log_queue_depth > 4096)) {
            throw new \InvalidArgumentException('invalid value for $packet_log_queue_depth when calling InlineObject75., must be smaller than or equal to 4096.');
        }
        if (!is_null($packet_log_queue_depth) && ($packet_log_queue_depth < 128)) {
            throw new \InvalidArgumentException('invalid value for $packet_log_queue_depth when calling InlineObject75., must be bigger than or equal to 128.');
        }

        $this->container['packet_log_queue_depth'] = $packet_log_queue_depth;

        return $this;
    }

    /**
     * Gets ngfw_max_scan_range
     *
     * @return int|null
     */
    public function getNgfwMaxScanRange()
    {
        return $this->container['ngfw_max_scan_range'];
    }

    /**
     * Sets ngfw_max_scan_range
     *
     * @param int|null $ngfw_max_scan_range NGFW policy-mode app detection threshold.
     *
     * @return self
     */
    public function setNgfwMaxScanRange($ngfw_max_scan_range)
    {

        if (!is_null($ngfw_max_scan_range) && ($ngfw_max_scan_range > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $ngfw_max_scan_range when calling InlineObject75., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($ngfw_max_scan_range) && ($ngfw_max_scan_range < 0)) {
            throw new \InvalidArgumentException('invalid value for $ngfw_max_scan_range when calling InlineObject75., must be bigger than or equal to 0.');
        }

        $this->container['ngfw_max_scan_range'] = $ngfw_max_scan_range;

        return $this;
    }

    /**
     * Gets tls_active_probe
     *
     * @return \Fortigate\FortiOS\Model\CMDB\IpsGlobalTlsActiveProbe[]|null
     */
    public function getTlsActiveProbe()
    {
        return $this->container['tls_active_probe'];
    }

    /**
     * Sets tls_active_probe
     *
     * @param \Fortigate\FortiOS\Model\CMDB\IpsGlobalTlsActiveProbe[]|null $tls_active_probe TLS active probe configuration.
     *
     * @return self
     */
    public function setTlsActiveProbe($tls_active_probe)
    {

        if (!is_null($tls_active_probe) && (count($tls_active_probe) > 0)) {
            throw new \InvalidArgumentException('invalid value for $tls_active_probe when calling InlineObject75., number of items must be less than or equal to 0.');
        }
        $this->container['tls_active_probe'] = $tls_active_probe;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


