<?php
/**
 * IpsSensorNameEntries
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * FortiOS CMDB
 *
 * REST API for configuring FortiOS objects and settings
 *
 * The version of the OpenAPI document: v2
 * Contact: fosguiqateam@fortinet.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Fortigate\FortiOS\Model\CMDB;

use \ArrayAccess;
use \Fortigate\FortiOS\ObjectSerializer;

/**
 * IpsSensorNameEntries Class Doc Comment
 *
 * @category Class
 * @package  Fortigate\FortiOS
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class IpsSensorNameEntries implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = '_ips_sensor__name__entries';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'int',
        'rule' => '\Fortigate\FortiOS\Model\CMDB\IpsSensorNameRule[]',
        'location' => 'string',
        'severity' => 'string',
        'protocol' => 'string',
        'os' => 'string',
        'application' => 'string',
        'cve' => '\Fortigate\FortiOS\Model\CMDB\IpsSensorNameCve[]',
        'status' => 'string',
        'log' => 'string',
        'log_packet' => 'string',
        'log_attack_context' => 'string',
        'action' => 'string',
        'rate_count' => 'int',
        'rate_duration' => 'int',
        'rate_mode' => 'string',
        'rate_track' => 'string',
        'exempt_ip' => '\Fortigate\FortiOS\Model\CMDB\IpsSensorNameExemptIp[]',
        'quarantine' => 'string',
        'quarantine_expiry' => 'string',
        'quarantine_log' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => null,
        'rule' => null,
        'location' => null,
        'severity' => null,
        'protocol' => null,
        'os' => null,
        'application' => null,
        'cve' => null,
        'status' => null,
        'log' => null,
        'log_packet' => null,
        'log_attack_context' => null,
        'action' => null,
        'rate_count' => null,
        'rate_duration' => null,
        'rate_mode' => null,
        'rate_track' => null,
        'exempt_ip' => null,
        'quarantine' => null,
        'quarantine_expiry' => null,
        'quarantine_log' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'rule' => 'rule',
        'location' => 'location',
        'severity' => 'severity',
        'protocol' => 'protocol',
        'os' => 'os',
        'application' => 'application',
        'cve' => 'cve',
        'status' => 'status',
        'log' => 'log',
        'log_packet' => 'log-packet',
        'log_attack_context' => 'log-attack-context',
        'action' => 'action',
        'rate_count' => 'rate-count',
        'rate_duration' => 'rate-duration',
        'rate_mode' => 'rate-mode',
        'rate_track' => 'rate-track',
        'exempt_ip' => 'exempt-ip',
        'quarantine' => 'quarantine',
        'quarantine_expiry' => 'quarantine-expiry',
        'quarantine_log' => 'quarantine-log'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'rule' => 'setRule',
        'location' => 'setLocation',
        'severity' => 'setSeverity',
        'protocol' => 'setProtocol',
        'os' => 'setOs',
        'application' => 'setApplication',
        'cve' => 'setCve',
        'status' => 'setStatus',
        'log' => 'setLog',
        'log_packet' => 'setLogPacket',
        'log_attack_context' => 'setLogAttackContext',
        'action' => 'setAction',
        'rate_count' => 'setRateCount',
        'rate_duration' => 'setRateDuration',
        'rate_mode' => 'setRateMode',
        'rate_track' => 'setRateTrack',
        'exempt_ip' => 'setExemptIp',
        'quarantine' => 'setQuarantine',
        'quarantine_expiry' => 'setQuarantineExpiry',
        'quarantine_log' => 'setQuarantineLog'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'rule' => 'getRule',
        'location' => 'getLocation',
        'severity' => 'getSeverity',
        'protocol' => 'getProtocol',
        'os' => 'getOs',
        'application' => 'getApplication',
        'cve' => 'getCve',
        'status' => 'getStatus',
        'log' => 'getLog',
        'log_packet' => 'getLogPacket',
        'log_attack_context' => 'getLogAttackContext',
        'action' => 'getAction',
        'rate_count' => 'getRateCount',
        'rate_duration' => 'getRateDuration',
        'rate_mode' => 'getRateMode',
        'rate_track' => 'getRateTrack',
        'exempt_ip' => 'getExemptIp',
        'quarantine' => 'getQuarantine',
        'quarantine_expiry' => 'getQuarantineExpiry',
        'quarantine_log' => 'getQuarantineLog'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const STATUS_DISABLE = 'disable';
    const STATUS_ENABLE = 'enable';
    const STATUS__DEFAULT = 'default';
    const LOG_DISABLE = 'disable';
    const LOG_ENABLE = 'enable';
    const LOG_PACKET_DISABLE = 'disable';
    const LOG_PACKET_ENABLE = 'enable';
    const LOG_ATTACK_CONTEXT_DISABLE = 'disable';
    const LOG_ATTACK_CONTEXT_ENABLE = 'enable';
    const ACTION_PASS = 'pass';
    const ACTION_BLOCK = 'block';
    const ACTION_RESET = 'reset';
    const ACTION__DEFAULT = 'default';
    const RATE_MODE_PERIODICAL = 'periodical';
    const RATE_MODE_CONTINUOUS = 'continuous';
    const RATE_TRACK_NONE = 'none';
    const RATE_TRACK_SRC_IP = 'src-ip';
    const RATE_TRACK_DEST_IP = 'dest-ip';
    const RATE_TRACK_DHCP_CLIENT_MAC = 'dhcp-client-mac';
    const RATE_TRACK_DNS_DOMAIN = 'dns-domain';
    const QUARANTINE_NONE = 'none';
    const QUARANTINE_ATTACKER = 'attacker';
    const QUARANTINE_LOG_DISABLE = 'disable';
    const QUARANTINE_LOG_ENABLE = 'enable';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_DISABLE,
            self::STATUS_ENABLE,
            self::STATUS__DEFAULT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLogAllowableValues()
    {
        return [
            self::LOG_DISABLE,
            self::LOG_ENABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLogPacketAllowableValues()
    {
        return [
            self::LOG_PACKET_DISABLE,
            self::LOG_PACKET_ENABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLogAttackContextAllowableValues()
    {
        return [
            self::LOG_ATTACK_CONTEXT_DISABLE,
            self::LOG_ATTACK_CONTEXT_ENABLE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getActionAllowableValues()
    {
        return [
            self::ACTION_PASS,
            self::ACTION_BLOCK,
            self::ACTION_RESET,
            self::ACTION__DEFAULT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRateModeAllowableValues()
    {
        return [
            self::RATE_MODE_PERIODICAL,
            self::RATE_MODE_CONTINUOUS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRateTrackAllowableValues()
    {
        return [
            self::RATE_TRACK_NONE,
            self::RATE_TRACK_SRC_IP,
            self::RATE_TRACK_DEST_IP,
            self::RATE_TRACK_DHCP_CLIENT_MAC,
            self::RATE_TRACK_DNS_DOMAIN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getQuarantineAllowableValues()
    {
        return [
            self::QUARANTINE_NONE,
            self::QUARANTINE_ATTACKER,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getQuarantineLogAllowableValues()
    {
        return [
            self::QUARANTINE_LOG_DISABLE,
            self::QUARANTINE_LOG_ENABLE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = $data['id'] ?? null;
        $this->container['rule'] = $data['rule'] ?? null;
        $this->container['location'] = $data['location'] ?? null;
        $this->container['severity'] = $data['severity'] ?? null;
        $this->container['protocol'] = $data['protocol'] ?? null;
        $this->container['os'] = $data['os'] ?? null;
        $this->container['application'] = $data['application'] ?? null;
        $this->container['cve'] = $data['cve'] ?? null;
        $this->container['status'] = $data['status'] ?? null;
        $this->container['log'] = $data['log'] ?? null;
        $this->container['log_packet'] = $data['log_packet'] ?? null;
        $this->container['log_attack_context'] = $data['log_attack_context'] ?? null;
        $this->container['action'] = $data['action'] ?? null;
        $this->container['rate_count'] = $data['rate_count'] ?? null;
        $this->container['rate_duration'] = $data['rate_duration'] ?? null;
        $this->container['rate_mode'] = $data['rate_mode'] ?? null;
        $this->container['rate_track'] = $data['rate_track'] ?? null;
        $this->container['exempt_ip'] = $data['exempt_ip'] ?? null;
        $this->container['quarantine'] = $data['quarantine'] ?? null;
        $this->container['quarantine_expiry'] = $data['quarantine_expiry'] ?? null;
        $this->container['quarantine_log'] = $data['quarantine_log'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['id']) && ($this->container['id'] > 4294967295)) {
            $invalidProperties[] = "invalid value for 'id', must be smaller than or equal to 4294967295.";
        }

        if (!is_null($this->container['id']) && ($this->container['id'] < 0)) {
            $invalidProperties[] = "invalid value for 'id', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['rule']) && (count($this->container['rule']) > 0)) {
            $invalidProperties[] = "invalid value for 'rule', number of items must be less than or equal to 0.";
        }

        if (!is_null($this->container['cve']) && (count($this->container['cve']) > 0)) {
            $invalidProperties[] = "invalid value for 'cve', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLogAllowableValues();
        if (!is_null($this->container['log']) && !in_array($this->container['log'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'log', must be one of '%s'",
                $this->container['log'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLogPacketAllowableValues();
        if (!is_null($this->container['log_packet']) && !in_array($this->container['log_packet'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'log_packet', must be one of '%s'",
                $this->container['log_packet'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLogAttackContextAllowableValues();
        if (!is_null($this->container['log_attack_context']) && !in_array($this->container['log_attack_context'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'log_attack_context', must be one of '%s'",
                $this->container['log_attack_context'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getActionAllowableValues();
        if (!is_null($this->container['action']) && !in_array($this->container['action'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'action', must be one of '%s'",
                $this->container['action'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['rate_count']) && ($this->container['rate_count'] > 65535)) {
            $invalidProperties[] = "invalid value for 'rate_count', must be smaller than or equal to 65535.";
        }

        if (!is_null($this->container['rate_count']) && ($this->container['rate_count'] < 0)) {
            $invalidProperties[] = "invalid value for 'rate_count', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['rate_duration']) && ($this->container['rate_duration'] > 65535)) {
            $invalidProperties[] = "invalid value for 'rate_duration', must be smaller than or equal to 65535.";
        }

        if (!is_null($this->container['rate_duration']) && ($this->container['rate_duration'] < 1)) {
            $invalidProperties[] = "invalid value for 'rate_duration', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getRateModeAllowableValues();
        if (!is_null($this->container['rate_mode']) && !in_array($this->container['rate_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'rate_mode', must be one of '%s'",
                $this->container['rate_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRateTrackAllowableValues();
        if (!is_null($this->container['rate_track']) && !in_array($this->container['rate_track'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'rate_track', must be one of '%s'",
                $this->container['rate_track'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['exempt_ip']) && (count($this->container['exempt_ip']) > 0)) {
            $invalidProperties[] = "invalid value for 'exempt_ip', number of items must be less than or equal to 0.";
        }

        $allowedValues = $this->getQuarantineAllowableValues();
        if (!is_null($this->container['quarantine']) && !in_array($this->container['quarantine'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'quarantine', must be one of '%s'",
                $this->container['quarantine'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getQuarantineLogAllowableValues();
        if (!is_null($this->container['quarantine_log']) && !in_array($this->container['quarantine_log'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'quarantine_log', must be one of '%s'",
                $this->container['quarantine_log'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id Rule ID in IPS database (0 - 4294967295).
     *
     * @return self
     */
    public function setId($id)
    {

        if (!is_null($id) && ($id > 4294967295)) {
            throw new \InvalidArgumentException('invalid value for $id when calling IpsSensorNameEntries., must be smaller than or equal to 4294967295.');
        }
        if (!is_null($id) && ($id < 0)) {
            throw new \InvalidArgumentException('invalid value for $id when calling IpsSensorNameEntries., must be bigger than or equal to 0.');
        }

        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets rule
     *
     * @return \Fortigate\FortiOS\Model\CMDB\IpsSensorNameRule[]|null
     */
    public function getRule()
    {
        return $this->container['rule'];
    }

    /**
     * Sets rule
     *
     * @param \Fortigate\FortiOS\Model\CMDB\IpsSensorNameRule[]|null $rule Identifies the predefined or custom IPS signatures to add to the sensor.
     *
     * @return self
     */
    public function setRule($rule)
    {

        if (!is_null($rule) && (count($rule) > 0)) {
            throw new \InvalidArgumentException('invalid value for $rule when calling IpsSensorNameEntries., number of items must be less than or equal to 0.');
        }
        $this->container['rule'] = $rule;

        return $this;
    }

    /**
     * Gets location
     *
     * @return string|null
     */
    public function getLocation()
    {
        return $this->container['location'];
    }

    /**
     * Sets location
     *
     * @param string|null $location Protect client or server traffic.
     *
     * @return self
     */
    public function setLocation($location)
    {
        $this->container['location'] = $location;

        return $this;
    }

    /**
     * Gets severity
     *
     * @return string|null
     */
    public function getSeverity()
    {
        return $this->container['severity'];
    }

    /**
     * Sets severity
     *
     * @param string|null $severity Relative severity of the signature, from info to critical. Log messages generated by the signature include the severity.
     *
     * @return self
     */
    public function setSeverity($severity)
    {
        $this->container['severity'] = $severity;

        return $this;
    }

    /**
     * Gets protocol
     *
     * @return string|null
     */
    public function getProtocol()
    {
        return $this->container['protocol'];
    }

    /**
     * Sets protocol
     *
     * @param string|null $protocol Protocols to be examined. set protocol ? lists available protocols. all includes all protocols. other includes all unlisted protocols.
     *
     * @return self
     */
    public function setProtocol($protocol)
    {
        $this->container['protocol'] = $protocol;

        return $this;
    }

    /**
     * Gets os
     *
     * @return string|null
     */
    public function getOs()
    {
        return $this->container['os'];
    }

    /**
     * Sets os
     *
     * @param string|null $os Operating systems to be protected.  all includes all operating systems. other includes all unlisted operating systems.
     *
     * @return self
     */
    public function setOs($os)
    {
        $this->container['os'] = $os;

        return $this;
    }

    /**
     * Gets application
     *
     * @return string|null
     */
    public function getApplication()
    {
        return $this->container['application'];
    }

    /**
     * Sets application
     *
     * @param string|null $application Applications to be protected. set application ? lists available applications. all includes all applications. other includes all unlisted applications.
     *
     * @return self
     */
    public function setApplication($application)
    {
        $this->container['application'] = $application;

        return $this;
    }

    /**
     * Gets cve
     *
     * @return \Fortigate\FortiOS\Model\CMDB\IpsSensorNameCve[]|null
     */
    public function getCve()
    {
        return $this->container['cve'];
    }

    /**
     * Sets cve
     *
     * @param \Fortigate\FortiOS\Model\CMDB\IpsSensorNameCve[]|null $cve List of CVE IDs of the signatures to add to the sensor
     *
     * @return self
     */
    public function setCve($cve)
    {

        if (!is_null($cve) && (count($cve) > 0)) {
            throw new \InvalidArgumentException('invalid value for $cve when calling IpsSensorNameEntries., number of items must be less than or equal to 0.');
        }
        $this->container['cve'] = $cve;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Status of the signatures included in filter. default enables the filter and only use filters with default status of enable. Filters with default status of disable will not be used.    disable:Disable status of selected rules.    enable:Enable status of selected rules.    default:Default.
     *
     * @return self
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets log
     *
     * @return string|null
     */
    public function getLog()
    {
        return $this->container['log'];
    }

    /**
     * Sets log
     *
     * @param string|null $log Enable/disable logging of signatures included in filter.    disable:Disable logging of selected rules.    enable:Enable logging of selected rules.
     *
     * @return self
     */
    public function setLog($log)
    {
        $allowedValues = $this->getLogAllowableValues();
        if (!is_null($log) && !in_array($log, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'log', must be one of '%s'",
                    $log,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['log'] = $log;

        return $this;
    }

    /**
     * Gets log_packet
     *
     * @return string|null
     */
    public function getLogPacket()
    {
        return $this->container['log_packet'];
    }

    /**
     * Sets log_packet
     *
     * @param string|null $log_packet Enable/disable packet logging. Enable to save the packet that triggers the filter. You can download the packets in pcap format for diagnostic use.    disable:Disable packet logging of selected rules.    enable:Enable packet logging of selected rules.
     *
     * @return self
     */
    public function setLogPacket($log_packet)
    {
        $allowedValues = $this->getLogPacketAllowableValues();
        if (!is_null($log_packet) && !in_array($log_packet, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'log_packet', must be one of '%s'",
                    $log_packet,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['log_packet'] = $log_packet;

        return $this;
    }

    /**
     * Gets log_attack_context
     *
     * @return string|null
     */
    public function getLogAttackContext()
    {
        return $this->container['log_attack_context'];
    }

    /**
     * Sets log_attack_context
     *
     * @param string|null $log_attack_context Enable/disable logging of attack context: URL buffer, header buffer, body buffer, packet buffer.    disable:Disable logging of detailed attack context.    enable:Enable logging of detailed attack context.
     *
     * @return self
     */
    public function setLogAttackContext($log_attack_context)
    {
        $allowedValues = $this->getLogAttackContextAllowableValues();
        if (!is_null($log_attack_context) && !in_array($log_attack_context, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'log_attack_context', must be one of '%s'",
                    $log_attack_context,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['log_attack_context'] = $log_attack_context;

        return $this;
    }

    /**
     * Gets action
     *
     * @return string|null
     */
    public function getAction()
    {
        return $this->container['action'];
    }

    /**
     * Sets action
     *
     * @param string|null $action Action taken with traffic in which signatures are detected.    pass:Pass or allow matching traffic.    block:Block or drop matching traffic.    reset:Reset sessions for matching traffic.    default:Pass or drop matching traffic, depending on the default action of the signature.
     *
     * @return self
     */
    public function setAction($action)
    {
        $allowedValues = $this->getActionAllowableValues();
        if (!is_null($action) && !in_array($action, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'action', must be one of '%s'",
                    $action,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['action'] = $action;

        return $this;
    }

    /**
     * Gets rate_count
     *
     * @return int|null
     */
    public function getRateCount()
    {
        return $this->container['rate_count'];
    }

    /**
     * Sets rate_count
     *
     * @param int|null $rate_count Count of the rate.
     *
     * @return self
     */
    public function setRateCount($rate_count)
    {

        if (!is_null($rate_count) && ($rate_count > 65535)) {
            throw new \InvalidArgumentException('invalid value for $rate_count when calling IpsSensorNameEntries., must be smaller than or equal to 65535.');
        }
        if (!is_null($rate_count) && ($rate_count < 0)) {
            throw new \InvalidArgumentException('invalid value for $rate_count when calling IpsSensorNameEntries., must be bigger than or equal to 0.');
        }

        $this->container['rate_count'] = $rate_count;

        return $this;
    }

    /**
     * Gets rate_duration
     *
     * @return int|null
     */
    public function getRateDuration()
    {
        return $this->container['rate_duration'];
    }

    /**
     * Sets rate_duration
     *
     * @param int|null $rate_duration Duration (sec) of the rate.
     *
     * @return self
     */
    public function setRateDuration($rate_duration)
    {

        if (!is_null($rate_duration) && ($rate_duration > 65535)) {
            throw new \InvalidArgumentException('invalid value for $rate_duration when calling IpsSensorNameEntries., must be smaller than or equal to 65535.');
        }
        if (!is_null($rate_duration) && ($rate_duration < 1)) {
            throw new \InvalidArgumentException('invalid value for $rate_duration when calling IpsSensorNameEntries., must be bigger than or equal to 1.');
        }

        $this->container['rate_duration'] = $rate_duration;

        return $this;
    }

    /**
     * Gets rate_mode
     *
     * @return string|null
     */
    public function getRateMode()
    {
        return $this->container['rate_mode'];
    }

    /**
     * Sets rate_mode
     *
     * @param string|null $rate_mode Rate limit mode.    periodical:Allow configured number of packets every rate-duration.    continuous:Block packets once the rate is reached.
     *
     * @return self
     */
    public function setRateMode($rate_mode)
    {
        $allowedValues = $this->getRateModeAllowableValues();
        if (!is_null($rate_mode) && !in_array($rate_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'rate_mode', must be one of '%s'",
                    $rate_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['rate_mode'] = $rate_mode;

        return $this;
    }

    /**
     * Gets rate_track
     *
     * @return string|null
     */
    public function getRateTrack()
    {
        return $this->container['rate_track'];
    }

    /**
     * Sets rate_track
     *
     * @param string|null $rate_track Track the packet protocol field.    none:none    src-ip:Source IP.    dest-ip:Destination IP.    dhcp-client-mac:DHCP client.    dns-domain:DNS domain.
     *
     * @return self
     */
    public function setRateTrack($rate_track)
    {
        $allowedValues = $this->getRateTrackAllowableValues();
        if (!is_null($rate_track) && !in_array($rate_track, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'rate_track', must be one of '%s'",
                    $rate_track,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['rate_track'] = $rate_track;

        return $this;
    }

    /**
     * Gets exempt_ip
     *
     * @return \Fortigate\FortiOS\Model\CMDB\IpsSensorNameExemptIp[]|null
     */
    public function getExemptIp()
    {
        return $this->container['exempt_ip'];
    }

    /**
     * Sets exempt_ip
     *
     * @param \Fortigate\FortiOS\Model\CMDB\IpsSensorNameExemptIp[]|null $exempt_ip Traffic from selected source or destination IP addresses is exempt from this signature.
     *
     * @return self
     */
    public function setExemptIp($exempt_ip)
    {

        if (!is_null($exempt_ip) && (count($exempt_ip) > 0)) {
            throw new \InvalidArgumentException('invalid value for $exempt_ip when calling IpsSensorNameEntries., number of items must be less than or equal to 0.');
        }
        $this->container['exempt_ip'] = $exempt_ip;

        return $this;
    }

    /**
     * Gets quarantine
     *
     * @return string|null
     */
    public function getQuarantine()
    {
        return $this->container['quarantine'];
    }

    /**
     * Sets quarantine
     *
     * @param string|null $quarantine Quarantine method.    none:Quarantine is disabled.    attacker:Block all traffic sent from attacker's IP address. The attacker's IP address is also added to the banned user list. The target's address is not affected.
     *
     * @return self
     */
    public function setQuarantine($quarantine)
    {
        $allowedValues = $this->getQuarantineAllowableValues();
        if (!is_null($quarantine) && !in_array($quarantine, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'quarantine', must be one of '%s'",
                    $quarantine,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['quarantine'] = $quarantine;

        return $this;
    }

    /**
     * Gets quarantine_expiry
     *
     * @return string|null
     */
    public function getQuarantineExpiry()
    {
        return $this->container['quarantine_expiry'];
    }

    /**
     * Sets quarantine_expiry
     *
     * @param string|null $quarantine_expiry Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
     *
     * @return self
     */
    public function setQuarantineExpiry($quarantine_expiry)
    {
        $this->container['quarantine_expiry'] = $quarantine_expiry;

        return $this;
    }

    /**
     * Gets quarantine_log
     *
     * @return string|null
     */
    public function getQuarantineLog()
    {
        return $this->container['quarantine_log'];
    }

    /**
     * Sets quarantine_log
     *
     * @param string|null $quarantine_log Enable/disable quarantine logging.    disable:Disable quarantine logging.    enable:Enable quarantine logging.
     *
     * @return self
     */
    public function setQuarantineLog($quarantine_log)
    {
        $allowedValues = $this->getQuarantineLogAllowableValues();
        if (!is_null($quarantine_log) && !in_array($quarantine_log, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'quarantine_log', must be one of '%s'",
                    $quarantine_log,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['quarantine_log'] = $quarantine_log;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


